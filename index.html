<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ROCKET MO — v1.81</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing:border-box }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent }
  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%,-50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
  }
  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }
  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .splash{
    pointer-events:auto; width:min(720px,94vw);
    background:rgba(20,24,28,.86); color:#fff; border-radius:18px;
    border:1px solid rgba(255,255,255,.12); backdrop-filter:blur(6px);
    box-shadow:0 22px 60px rgba(0,0,0,.55); padding:32px 26px 22px; text-align:center;
  }
  .splash h1{ margin:0 0 8px; font-weight:800; font-size:clamp(28px,7.2vw,56px);
    background: linear-gradient(180deg,#ffd54a 0%,#fff7c5 35%,#ff7a3a 100%);
    -webkit-background-clip:text; background-clip:text; color:transparent; }
  .splash .hint{ opacity:.9; font-size:12px }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff }
  .hidden{ display:none }
  #sysImg{ max-width:100%; max-height:240px; object-fit:contain; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px; margin:10px auto; display:none; opacity:0; transition:opacity .25s ease; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:9; pointer-events:none; }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>

<div class="overlay">
  <div id="splash" class="splash" tabindex="0" aria-label="Title Screen">
    <h1>ROCKET MO</h1>
    <div class="hint">Tap anywhere or press Space/Enter • Best is saved</div>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 • Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>
    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">—</span></div>
      <div id="sysBlurb" style="opacity:.95; font-size:13px; margin-bottom:8px">—</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
    </div>
  </div>
</div>

<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. You can still start from here.</p>
  </div>
</div>

<script>
(() => {
  const VERSION='1.81';
  const isMobile=/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  const W=1920,H=1080;
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d',{alpha:false});
  ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';

  function fitCSS(){
    const vw=innerWidth, vh=Math.round(window.visualViewport?visualViewport.height:innerHeight);
    const s=Math.min(vw/W, vh/H);
    const snapped=Math.round(s*100)/100;
    canvas.style.transform=`translate(-50%,-50%) scale(${snapped})`;
  }
  addEventListener('resize',fitCSS,{passive:true});
  window.visualViewport&&visualViewport.addEventListener('resize',fitCSS,{passive:true});
  fitCSS();

  function checkOrientation(){
    const rb=document.getElementById('rotBlock');
    rb.classList.toggle('show', isMobile && innerWidth<innerHeight);
  }
  addEventListener('resize',checkOrientation,{passive:true}); checkOrientation();

  let physicsHz=isMobile?90:60;
  let STEP=1/physicsHz,accumulator=0,lastTs=performance.now();
  const MAX_FRAME_DT=0.12;

  const SPEED_MULT=isMobile?1.40:1.50;
  const G=4800*SPEED_MULT, LIFT_V0=-1250*SPEED_MULT, MAX_FALL=2200*SPEED_MULT;
  const baseScroll=isMobile?480:440;
  const SCROLL_PPS=baseScroll*SPEED_MULT;

  const VERTICAL_X_GAP=Math.round(SCROLL_PPS*1.8);
  const FIRST_VERTICAL_LEAD=VERTICAL_X_GAP;

  const PIPE_W=180, GAP_MIN=310, GAP_MAX=450;
  const TOP_OVERLAP_FRAC=0.30, BOTTOM_OVERLAP_FRAC=0.75;
  const BIRD_INSET=8, GAP_FORGIVE=12;

  const BIRD_SPRITE_FRAMES=4, BIRD_SPRITE_FPS=12;
  const BIRD_SPRITE_SCALE=1.55;
  const BIRD_ANCHOR_X_FRAC=0.58, BIRD_ANCHOR_Y_FRAC=0.50;

  let birdSprite=null, birdFallbackImg=null, bgImg=null;

  const bird={
    x:Math.round(W*0.167),
    y:Math.round(H*0.5),
    w:Math.round(H*0.069),
    h:Math.round(H*0.069),
    v:0, yRender:0, animTime:0, angle:0,
    computeAngle(){ this.angle=Math.max(-0.45, Math.min(0.9,(this.v/600)*0.5)); return this.angle; },
    flap(){ if(state!=='playing') return; this.v=LIFT_V0; },
    reset(){ this.y=Math.round(H*0.5); this.v=0; this.animTime=0; this.angle=0; },
    draw(){
      const ang=this.computeAngle();
      ctx.save(); ctx.translate(this.x+this.w/2, this.yRender); ctx.rotate(ang);
      if(birdSprite && birdSprite.complete && birdSprite.naturalWidth){
        const frameW=Math.floor(birdSprite.naturalWidth/BIRD_SPRITE_FRAMES);
        const frameH=birdSprite.naturalHeight;
        const idx=Math.floor(this.animTime*BIRD_SPRITE_FPS)%BIRD_SPRITE_FRAMES;
        const sx=idx*frameW;
        const aspect=frameW/frameH, drawH=this.h, drawW=drawH*aspect*BIRD_SPRITE_SCALE;
        const ax=drawW*BIRD_ANCHOR_X_FRAC, ay=drawH*BIRD_ANCHOR_Y_FRAC;
        ctx.drawImage(birdSprite, sx,0,frameW,frameH, -ax,-ay, drawW,drawH);
      } else if(birdFallbackImg && birdFallbackImg.complete && birdFallbackImg.naturalWidth){
        ctx.drawImage(birdFallbackImg, -this.w/2, -this.h/2, this.w, this.h);
      } else { ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h); }
      ctx.restore();
    }
  };

  function loadImageWithTimeout(src,timeout=6000){
    return new Promise((res)=>{ if(!src){ res(null); return; }
      const img=new Image(); img.referrerPolicy='no-referrer';
      let done=false; const finish=v=>{ if(done)return; done=true; res(v||null); };
      const t=setTimeout(()=>finish(null),timeout);
      img.onload=()=>{ clearTimeout(t); finish(img); };
      img.onerror=()=>{ clearTimeout(t); finish(null); };
      img.src=src;
    });
  }
  let bgCache=null;
  function buildBgCache(){
    const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
    const g1=g.createLinearGradient(0,0,0,H); g1.addColorStop(0,'#0f1116'); g1.addColorStop(1,'#1a1e26'); g.fillStyle=g1; g.fillRect(0,0,W,H);
    const r1=g.createRadialGradient(W*0.16,H*0.25,50, W*0.16,H*0.25,420); r1.addColorStop(0,'rgba(255,210,90,0.18)'); r1.addColorStop(1,'rgba(255,210,90,0)'); g.fillStyle=r1; g.fillRect(0,0,W,H);
    const r2=g.createRadialGradient(W*0.85,H*0.35,50, W*0.85,H*0.35,520); r2.addColorStop(0,'rgba(255,120,60,0.14)'); r2.addColorStop(1,'rgba(255,120,60,0)'); g.fillStyle=r2; g.fillRect(0,0,W,H);
    return c;
  }
  function drawBackground(){ if(bgImg){ ctx.drawImage(bgImg,0,0,W,H); return; } if(!bgCache) bgCache=buildBgCache(); ctx.drawImage(bgCache,0,0); }

  const PIPE_STYLES_CFG=[
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] }, Styles=[];
  function makeScaledCanvas(img,w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#2e8b57"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img,drawW,capPxSrc,capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.imageSmoothingEnabled=true; g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return {cap:ph, body:ph}; }
    const scale=drawW/(img.naturalWidth||img.width);
    const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
    const capH=Math.max(1,Math.round(capPxSrc*scale));
    const full=makeScaledCanvas(img,drawW,scaledH);
    const cap=document.createElement("canvas"), body=document.createElement("canvas");
    cap.width=drawW; cap.height=Math.min(capH,scaledH);
    body.width=drawW; body.height=Math.max(1,scaledH-cap.height);
    const cg=cap.getContext("2d"), bg=body.getContext("2d"); cg.imageSmoothingEnabled=bg.imageSmoothingEnabled=true;
    if(capFrom==="top"){ cg.drawImage(full,0,0,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,cap.height,drawW,body.height,0,0,drawW,body.height); }
    else { cg.drawImage(full,0,scaledH-cap.height,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,0,drawW,body.height,0,0,drawW,body.height); }
    return { cap, body };
  }
  function rebuildStyles(){ Styles.length=0; for(let i=0;i<PIPE_STYLES_CFG.length;i++){ const cfg=PIPE_STYLES_CFG[i]; const bot=Raw.bottoms[i], top=Raw.tops[i]; const drawW=Math.round(PIPE_W*(cfg.scale||1)); const bottom=buildCapBodyPx(bot,drawW,cfg.bottom.capPx,cfg.bottom.capFrom); const topset=buildCapBodyPx(top,drawW,cfg.top.capPx,cfg.top.capFrom); Styles.push({ name:cfg.name, bottom, top:topset, drawW }); } }

  function drawBodyTiled(g,tile,x,yStart,totalH,w,mode){
    const th=tile.height; if(totalH<=0||th<=0) return;
    if(mode==="topUp"){ let y=totalH-th; while(y>=0){ g.drawImage(tile,x,y,w,th); y-=th; } const rem=totalH%th; if(rem>0) g.drawImage(tile,0,th-rem,tile.width,rem,x,0,w,rem); }
    else { let y=yStart, end=yStart+totalH; while(y+th<=end){ g.drawImage(tile,x,y,w,th); y+=th; } const left=end-y; if(left>0) g.drawImage(tile,0,0,tile.width,left,x,y,w,left); }
  }
  function makeVerticalSprite(sty,top,gap,w){
    const c=document.createElement('canvas'); c.width=w; c.height=H; const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(top>0){ const cap=sty.top.cap, body=sty.top.body; const capH=Math.min(cap.height,top), bodyH=top-capH; if(bodyH>0) drawBodyTiled(g,body,0,0,bodyH,w,"topUp"); g.drawImage(cap,0,top-capH,w,capH); }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){ const cap=sty.bottom.cap, body=sty.bottom.body; const capH=Math.min(cap.height,bottomH); g.drawImage(cap,0,by,w,capH); const remain=bottomH-capH; if(remain>0) drawBodyTiled(g,body,0,by+capH,remain,w,"bottomDown"); }
    return c;
  }
  function makeHorizontalSprite(sty,len){
    const body=sty.bottom.body;
    const thick=body.width;
    const tile=document.createElement('canvas');
    tile.width=body.height;
    tile.height=thick;
    const tg=tile.getContext('2d'); tg.imageSmoothingEnabled=true;
    tg.save(); tg.translate(0, tile.height); tg.rotate(-Math.PI/2); tg.drawImage(body,0,0); tg.restore();
    const c=document.createElement('canvas'); c.width=len; c.height=thick;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    let x=0; while(x+tile.width<=len){ g.drawImage(tile,x,0); x+=tile.width; }
    const rem=len-x; if(rem>0) g.drawImage(tile,0,0,rem,tile.height,x,0,rem,tile.height);
    return c;
  }

  const obstacles=[];
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  const H_BUFFER=Math.round(W*0.06);
  const H_BETWEEN=Math.round(W*0.25);
  const H_BAR_LEN=Math.round(W*0.55);

  function spawnVerticalAt(xPos){
    if(!Styles.length) return;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin;
    const minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin); if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap); if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    const idx=Math.floor(Math.random()*Styles.length), sty=Styles[idx], w=sty.drawW;
    obstacles.push({ type:'V', x:xPos, top, gap, w, styleIndex:idx, scored:false, sprite:makeVerticalSprite(sty,top,gap,w) });
  }
  function spawnOneHorizontal(){
    const idx=Math.floor(Math.random()*Styles.length), sty=Styles[idx];
    const sprite=makeHorizontalSprite(sty,H_BAR_LEN);
    const thick=sprite.height;
    const margin=Math.round(H*0.12);
    const yMid=randInt(margin + thick/2, H - (margin + thick/2));
    obstacles.push({ type:'H', x:W, y:yMid, len:H_BAR_LEN, thick, styleIndex:idx, sprite, scored:false });
  }

  let patternMode='VERT', vertSpawned=0, hLeft=0, nextSpawnPx=FIRST_VERTICAL_LEAD;

  function stepSpawner(dt){
    nextSpawnPx-=SCROLL_PPS*dt;
    while(nextSpawnPx<=0){
      if(patternMode==='VERT'){
        spawnVerticalAt(W);
        vertSpawned++; nextSpawnPx+=VERTICAL_X_GAP;
        if(vertSpawned>=10){ patternMode='HSET'; hLeft=3; nextSpawnPx+=H_BUFFER; }
      }else{
        spawnOneHorizontal(); hLeft--;
        nextSpawnPx+=(hLeft>0?H_BETWEEN:H_BUFFER);
        if(hLeft<=0){ patternMode='VERT'; vertSpawned=0; }
      }
    }
  }

  function drawObstaclesInterpolated(leftover){
    for(const o of obstacles){
      if(o.type==='V'){
        const xR=(state==='playing')?(o.x - SCROLL_PPS*leftover):o.x;
        if(o.sprite) ctx.drawImage(o.sprite,xR,0,o.w,H);
      } else {
        const xR=(state==='playing')?(o.x - SCROLL_PPS*leftover):o.x;
        ctx.drawImage(o.sprite, xR, o.y - o.thick/2);
      }
    }
  }
  function cleanupObstacles(){
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if((o.type==='V' && o.x+o.w<=0) || (o.type==='H' && o.x+o.len<=0)) obstacles.splice(i,1);
    }
  }

  const scoreEl=document.getElementById('scoreVal'), lastEl=document.getElementById('lastVal'), bestEl=document.getElementById('bestVal');
  let score=0, lastScore=0;
  let best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent=best;

  function collideAndScore(leftover){
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);
    for(const o of obstacles){
      if(o.type==='V'){
        const xR=o.x - SCROLL_PPS*leftover;
        const overlapX=(bx2>xR)&&(bx1<xR+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){ endGame(o.styleIndex); return true; }
        }
        if(!o.scored && (xR+o.w)<bx1){
          o.scored=true; score++; scoreEl.textContent=score;
          if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); }
        }
      } else {
        const xR=o.x - SCROLL_PPS*leftover, rx1=xR, rx2=xR+o.len, ry1=o.y-o.thick/2, ry2=o.y+o.thick/2;
        const overlap=(bx2>rx1)&&(bx1<rx2)&&(by2>ry1)&&(by1<ry2);
        if(overlap){ endGame(o.styleIndex); return true; }
        if(!o.scored && rx2<bx1){
          o.scored=true; score++; scoreEl.textContent=score;
          if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); }
        }
      }
    }
    return false;
  }

  const splash=document.getElementById('splash');
  const gameOverCard=document.getElementById('gameOverCard');
  const finalScoreP=document.getElementById('finalScoreP');

  let state='title', restartLocked=false;

  function showTitle(){ state='title'; restartLocked=false;
    splash.classList.remove('hidden'); gameOverCard.classList.add('hidden');
    score=0; scoreEl.textContent='0'; bird.reset();
  }
  function startGame(){
    if(state==='playing') return;
    state='playing'; restartLocked=false;
    lastScore=score; lastEl.textContent=lastScore; score=0; scoreEl.textContent='0';
    obstacles.length=0; patternMode='VERT'; vertSpawned=0; hLeft=0; nextSpawnPx=FIRST_VERTICAL_LEAD;
    bird.reset(); splash.classList.add('hidden'); gameOverCard.classList.add('hidden');
  }
  function endGame(hitStyleIdx){
    if(state==='gameover') return;
    state='gameover'; bird.v=0;
    finalScoreP.textContent=`Score: ${score} • Best: ${best}`;
    fillSystemPanel(hitStyleIdx);
    gameOverCard.classList.remove('hidden'); gameOverCard.scrollTop=0;
    restartLocked=true; setTimeout(()=>{ restartLocked=false; },900);
  }

  function globalPointerStart(e){
    if(e.target.closest('#gameOverCard')) return;
    if(state==='title'){ startGame(); return; }
    if(state==='playing'){ e.preventDefault(); bird.flap(); return; }
    if(state==='gameover' && !restartLocked){ startGame(); }
  }
  document.addEventListener('pointerdown', globalPointerStart, {passive:false, capture:true});
  splash.addEventListener('click', ()=>{ if(state!=='playing') startGame(); }, {passive:true});
  splash.addEventListener('keydown',(e)=>{ if(e.key==='Enter'||e.code==='Space'||e.key===' '){ e.preventDefault(); startGame(); }});
  splash.setAttribute('tabindex','0');
  document.addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    if(e.code==='Space'||e.key===' '){
      if(state==='title') startGame();
      else if(state==='gameover'){ if(!restartLocked) startGame(); }
      else bird.flap();
      e.preventDefault();
    }
    if(e.key==='Enter'){
      if(state==='title') startGame(); else if(state==='gameover' && !restartLocked) startGame();
    }
  });

  const SYSTEMS=[
    { title:"EATNASTAK (DOUBLE FACE)", img:"assets/pipe1.png",
      blurb:"When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system offers unmatched flexibility, allowing you to reconfigure it as often as needed to suit your evolving preferences. Whether expanding your collection or rearranging your space, Aetnastak provides the adaptability and reliability you need for efficient and organized library management.",
      specs2:[["Specification","Standard Dimensions"],["Width","24, 30, 36\""],["Depth","7, 8, 9, 10, 11, 12, 13, 14, 15, 16\""],["Height","30, 31, …, 108\""],["Shelf Load Capacity","Up to 50 psf"]] },
    { title:"SMARTSHELF (FIXED, FULL DEPTH)", img:"assets/pipe2.png",
      blurb:"Montel's patented SmartShelf is the most versatile storage shelving system available today...",
      specs2:[["Specification","Standard Dimensions"],["Width","24, 30, 36, 1M, 42, 48, 54\""],["Depth","12, 13, 15, 16, 18, 20, 24, 30, 36\""],["Height","30, 31, …, 120\""],["Frame Load Capacity","Up to 2,500 lbs per frame"],["Shelf Load Capacity","Up to 500 lbs per shelf"]] },
    { title:"4D Wide Span", img:"assets/pipe3.png",
      blurb:"Montel’s 4D Wide Span semi-industrial racking offers the ultimate solution for storing large, heavy items with ease...",
      specs2:[["Specification","Capacity"],["Load per Bay","Up to 5,000 lbs per bay (2 268 kg)"],["Load per Level","3\" Beam : 1,000 lbs per pair of beam (454 kg)"],["Span","4\" Beam : 1,500 lbs per pair of beam (680 kg)"],["Height","4' to 8' (1.2 m to 2.4 m)"],["Depth","Up to 20' (6.1 m)"]] },
    { title:"SmartSpace", img:"assets/pipe4.png",
      blurb:"Montel’s SmartSpace storage system offers a cost-effective and versatile solution for organizing light objects...",
      specs2:[["Specification","Capacity"],["Section Load Capacity","2,000 lbs per section (907 kg)"],["Section Length","24\" to 48\" (0.61m - 1.2m)"],["Section Depth","Panels: 12\" to 48\" / Columns: 18\" to 48\""],["Carriage Load Capacity","16,000 lbs per carriage (7270kg)"],["Carriage Length","Max 24' (7.3 m)"]] },
    { title:"SmartGlide", img:"assets/pipe5.png",
      blurb:"Montel’s SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system...",
      specs2:null },
    { title:"GREENRAK", img:"assets/greenrak.png",
      blurb:"Montel’s GREENRAK® 2.0 mobile system has been developed specifically for growing applications...",
      specs3:{ headers:["Specification","Section","Mobile"], rows:[["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],["Depth","—","36”, 42”, 48”"],["Length","4’, 8’","Max 50’"]] } },
    { title:"Mobilex", img:"assets/pipe7.png",
      blurb:"Montel's Mobilex mechanical-assist mobile storage systems provide your organization with flexibility...",
      specs2:[["Specification","Capacity"],["Load Capacity","1,000 lbs per linear foot (1 488kg/m)"],["Depth","3' to 45' (0.91m - 13.7m)"],["Length","15\" to 48\" (0.4m - 2.4 m)"]] },
    { title:"SAFERAK 32P & 60P", img:"assets/pipe8.png",
      blurb:"Unlock the full potential of your storage with Montel’s cutting-edge powered mobile racking system...",
      specs3:{ headers:["Specification","SAFERAK 32P","SAFERAK 60P"], rows:[["Load per Double-Bay","32,000lbs (14 500 kg)","60,000lbs (27 200 kg)"],["Load per Carriage","256,000 lbs (116 000 kg)","480,000 lbs (217 600 kg)"],["Bay Depth","Up to 8' (2.4 m)","Up to 8' (2.4 m)"],["Bay Width","Up to 12' (3.6 m)","Up to 12' (3.6 m)"],["Carriage Length","Up to 100’ (30 m)","Up to 120’ (36 m)"],["Industrial Safeties","YES","YES"],["PLC","YES","YES"],["Touchscreen UI","YES","YES"],["Signal Strobe and Buzzers","YES","YES"],["VPN eWon Connectivity","YES","YES"],["Rear Controls","Optional","Optional"],["In-Aisle E-Stops","Optional","Optional"],["Illuminated E-Stops","Optional","Optional"]] } }
  ];

  function fillSystemPanel(hitStyleIdx){
    const imgEl=document.getElementById('sysImg');
    const box=document.getElementById('sysInfoBox');
    const tEl=document.getElementById('sysTitle');
    const bEl=document.getElementById('sysBlurb');
    const sBox=document.getElementById('sysSpecsBox');
    const sEl=document.getElementById('sysSpecs');

    if(typeof hitStyleIdx==='number' && SYSTEMS[hitStyleIdx]){
      const info=SYSTEMS[hitStyleIdx];
      tEl.textContent=info.title||`System ${hitStyleIdx+1}`;
      bEl.textContent=info.blurb||'';
      if(info.img){ imgEl.style.opacity='0'; imgEl.onload=()=>imgEl.style.opacity='1'; imgEl.src=info.img; imgEl.style.display='block'; } else imgEl.style.display='none';

      sEl.innerHTML='';
      if(info.specs3 && info.specs3.headers && info.specs3.rows){
        const h=info.specs3.headers;
        sEl.innerHTML='<thead><tr>'+h.map(x=>`<th>${x}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tb=sEl.querySelector('tbody');
        info.specs3.rows.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=r.map((c,i)=>`<td${i===0?' style="font-weight:600"':''}>${c}</td>`).join(''); tb.appendChild(tr); });
        sBox.style.display='block';
      } else if(info.specs2){
        const [header,...rows]=info.specs2;
        sEl.innerHTML='<thead><tr>'+header.map(x=>`<th>${x}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tb=sEl.querySelector('tbody');
        rows.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td style="font-weight:600">${r[0]}</td><td>${r[1]}</td>`; tb.appendChild(tr); });
        sBox.style.display='block';
      } else { sBox.style.display='none'; }
      box.style.display='block';
    } else { box.style.display='none'; imgEl.style.display='none'; }
  }

  function drawVersionTag(){ ctx.fillStyle='rgba(150,150,150,.95)'; ctx.font='700 10px Montserrat,system-ui'; ctx.fillText('v'+VERSION, 14, H-14); }

  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT)frameDt=MAX_FRAME_DT; if(frameDt<0)frameDt=0; lastTs=ts;
    accumulator+=frameDt;
    while(accumulator>=STEP){
      if(state==='playing'){
        bird.v+=G*STEP; if(bird.v>MAX_FALL) bird.v=MAX_FALL; bird.y+=bird.v*STEP;
        const topWrap=-bird.h*TOP_OVERLAP_FRAC, bottomWrap=H+bird.h*BOTTOM_OVERLAP_FRAC;
        if(bird.y<topWrap){ const over=topWrap-bird.y; bird.y=bottomWrap-over; }
        else if(bird.y>bottomWrap){ const over=bird.y-bottomWrap; bird.y=topWrap+over; }
        stepSpawner(STEP);
        for(const o of obstacles){ o.x-=SCROLL_PPS*STEP; }
        cleanupObstacles();
        bird.animTime+=STEP;
      }
      accumulator-=STEP;
    }
    const leftover=(state==='playing')?accumulator:0;
    ctx.clearRect(0,0,W,H);
    drawBackground();
    bird.yRender=bird.y + (state==='playing' ? bird.v*leftover + 0.5*G*leftover*leftover : 0);
    drawObstaclesInterpolated(leftover);
    bird.draw();
    if(state!=='title') drawVersionTag();
    if(state==='playing') collideAndScore(leftover);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  (async ()=>{
    try{
      const [sprite,fallback,bg,...rest]=await Promise.all([
        loadImageWithTimeout("assets/bird-sprite.png"),
        loadImageWithTimeout("assets/bird.png"),
        loadImageWithTimeout("assets/bg.png"),
        ...PIPE_STYLES_CFG.flatMap(s=>[loadImageWithTimeout(s.bottom.url), loadImageWithTimeout(s.top.url)])
      ]);
      birdSprite=sprite||null; birdFallbackImg=(!birdSprite && fallback)?fallback:null; bgImg=bg||null;
      const results=rest; const bottoms=[], tops=[];
      for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=results[i*2]||null; tops[i]=results[i*2+1]||null; }
      Raw.bottoms=bottoms; Raw.tops=tops; rebuildStyles();
    }catch(_){ rebuildStyles(); }
  })();

  // ---------- state now defined only once ----------
  showTitle();

})();
</script>
</body>
</html>
