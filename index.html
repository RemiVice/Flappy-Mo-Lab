<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flappy Mo â€” Local Assets (v1.45b-smooth60)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  /* Fixed world canvas (1920x1080). Only CSS scale changes. */
  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    box-shadow:0 10px 30px rgba(0,0,0,.5);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
    scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff; }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff; }
  .hidden{ display:none }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:999 }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  #loadingOverlay{
    position:fixed; inset:0; display:grid; place-items:center;
    background:#0b0d10; color:#fff; z-index:2000;
    font-weight:800; font-size:18px;
  }

  /* Game Over system panel visuals */
  #sysImg { max-width:100%; max-height:240px; object-fit:contain; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px; margin:10px 0; display:none; opacity:0; transition:opacity .25s ease; }
  /* Force ALL text inside the system box to white */
  #sysInfoBox, #sysInfoBox * { color:#fff !important; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">ðŸ”Š Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">â›¶ Fullscreen</button>

<!-- Overlays -->
<div class="overlay">
  <div id="startCard" class="card">
    <h1>Tap to Start</h1>
    <p>Tap again to flap â€¢ Best is saved</p>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 â€¢ Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>

    <!-- system info -->
    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">â€”</span></div>
      <div id="sysBlurb" style="opacity:.9; font-size:13px; margin-bottom:8px; white-space:pre-line">â€”</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<!-- Landscape-only blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. Turn your device to play.</p>
  </div>
</div>

<div id="loadingOverlay">Loadingâ€¦</div>

<script>
(() => {
  const VERSION = '1.45b-smooth60';
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  // WORLD space (never changes)
  const W = 1920, H = 1080;

  // Physics base
  const SPEED_MULT = isMobile ? 1.40 : 1.50;
  const G         = 4800 * SPEED_MULT;
  const LIFT_V0   = -1350 * SPEED_MULT;
  const MAX_FALL  = 2200 * SPEED_MULT;
  const SCROLL_PPS=  480 * SPEED_MULT;

  const PIPE_W    = 180;
  const GAP_MIN   = 310, GAP_MAX = 450;
  const PIPE_SPAWN_EVERY_S = 1.8;

  const BIRD_INSET = 8, GAP_FORGIVE = 12;

  // Canvas + fit via CSS only
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = true;
  function fit(){ const vw=innerWidth, vh=Math.round(visualViewport?visualViewport.height:innerHeight); const s=Math.min(vw/W, vh/H); canvas.style.transform=`translate(-50%, -50%) scale(${s})`; }
  addEventListener('resize', fit, {passive:true}); visualViewport&&visualViewport.addEventListener('resize', fit, {passive:true}); fit();

  // Orientation gate
  const rotBlock = document.getElementById('rotBlock');
  function checkOrientation(){ rotBlock.classList.toggle('show', innerWidth<innerHeight); }
  addEventListener('resize', checkOrientation, {passive:true}); checkOrientation();

  // UI refs
  const scoreEl = document.getElementById('scoreVal');
  const lastEl  = document.getElementById('lastVal');
  const bestEl  = document.getElementById('bestVal');
  const startCard   = document.getElementById('startCard');
  const gameOverCard= document.getElementById('gameOverCard');
  const finalScoreP = document.getElementById('finalScoreP');
  const fsBtn = document.getElementById('fsBtn');

  function inFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
  function updateFsBtn(){ const full=!!inFullscreen(); fsBtn.textContent = full ? "â¤¢ Exit" : "â›¶ Fullscreen"; }
  fsBtn.addEventListener('click', async (e)=>{ e.stopPropagation(); const el=document.documentElement; try{ if(!inFullscreen()){ await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.msRequestFullscreen?.()); } else { await (document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.msExitFullscreen?.()); } }catch(_){} updateFsBtn(); }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  // Game state
  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent = best;
  let spawnTimer = 0;

  // Audio (minimal, safe)
  let audioCtx=null, masterGain=null, audioReady=false, muted=false;
  function setMuted(m){ muted=m; if(masterGain) masterGain.gain.value = muted?0:1; const b=document.getElementById('muteBtn'); b.textContent = muted?"ðŸ”‡ Muted":"ðŸ”Š Sound"; b.setAttribute("aria-pressed", String(muted)); }
  document.getElementById('muteBtn').addEventListener('click', (e)=>{ e.stopPropagation(); setMuted(!muted); });
  async function initAudioOnce(){ if(audioReady) return; audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"}); masterGain=audioCtx.createGain(); masterGain.gain.value = muted?0:0.8; masterGain.connect(audioCtx.destination); try{ await audioCtx.resume(); }catch(_){} audioReady=true; }
  function woosh(d=.25){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<n;i++) data[i]=(Math.random()*2-1)*0.3; const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=1200; const g=audioCtx.createGain(); const t=audioCtx.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.4,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+d); src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(t+d+0.05); }
  const playFlap = ()=>woosh(.25);

  // Image helpers
  function loadImageWithTimeout(src, timeoutMs=6000){
    return new Promise((resolve) => {
      if(!src){ resolve(null); return; }
      const img = new Image(); img.referrerPolicy='no-referrer';
      let done=false; const finish=(v)=>{ if(done) return; done=true; resolve(v||null); };
      const timer=setTimeout(()=>finish(null), timeoutMs);
      img.onload=()=>{ clearTimeout(timer); finish(img); };
      img.onerror=()=>{ clearTimeout(timer); finish(null); };
      img.src=src;
    });
  }
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#3a3a3a"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return { cap:ph, body:ph }; }
    const scale = drawW / (img.naturalWidth || img.width);
    const scaledH = Math.max(1, Math.round((img.naturalHeight || img.height) * scale));
    const capH    = Math.max(1, Math.round(capPxSrc * scale));
    const full = makeScaledCanvas(img, drawW, scaledH);
    const cap  = document.createElement("canvas");
    const body = document.createElement("canvas");
    cap.width = drawW; cap.height = Math.min(capH, scaledH);
    body.width = drawW; body.height = Math.max(1, scaledH - cap.height);
    const cg = cap.getContext("2d"), bg = body.getContext("2d");
    cg.imageSmoothingEnabled = bg.imageSmoothingEnabled = true;
    if (capFrom === "top") {
      cg.drawImage(full, 0, 0, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, cap.height, drawW, body.height, 0, 0, drawW, body.height);
    } else {
      cg.drawImage(full, 0, scaledH - cap.height, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, 0, drawW, body.height, 0, 0, drawW, body.height);
    }
    return { cap, body };
  }

  // Pipes config + styles
  const PIPE_STYLES_CFG = [
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] };
  const Styles=[];
  function rebuildStyles(){
    Styles.length=0;
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      const cfg=PIPE_STYLES_CFG[i];
      const bot=Raw.bottoms[i], top=Raw.tops[i];
      const drawW = Math.round(PIPE_W * (cfg.scale || 1));
      const bottom = buildCapBodyPx(bot, drawW, cfg.bottom.capPx, cfg.bottom.capFrom);
      const topset = buildCapBodyPx(top, drawW, cfg.top.capPx,   cfg.top.capFrom);
      Styles.push({ name:cfg.name, bottom, top:topset, drawW });
    }
  }

  /* ===== Systems info (unchanged) ===== */
  const SYSTEMS = [
    { title: "EATNASTAK (DOUBLE FACE)",
      blurb:`When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system
offers unmatched flexibility, allowing you to reconfigure it as often as needed to suit your evolving preferences. Whether expanding
your collection or rearranging your space, Aetnastak provides the adaptability and reliability you need for efficient and organized
library management.`,
      img:"assets/pipe1.png", tds:"#",
      specHeaders:["Specification","Standard Dimensions"],
      specs:[
        ["Width","24, 30, 36\""],
        ["Depth","7, 8, 9, 10, 11, 12, 13, 14, 15, 16\""],
        ["Height","30, 31, â€¦, 108\""],
        ["Shelf Load Capacity","Up to 50 psf"]
      ]},
    { title:"SMARTSHELF (FIXED, FULL DEPTH)",
      blurb:"Montel's patented SmartShelf is the most versatile storage shelving system available today. This innovative 4-post shelving offers complete flexibility, accommodating items of all shapes and sizes. It is also designed for easy assembly and reconfiguration.",
      img:"assets/pipe2.png", tds:"#",
      specHeaders:["Specification","Standard Dimensions"],
      specs:[
        ["Width","24, 30, 36, 1M, 42, 48, 54\""],
        ["Depth","12, 13, 15, 16, 18, 20, 24, 30, 36\""],
        ["Height","30, 31, â€¦, 120\""],
        ["Frame Load Capacity","Up to 2,500 lbs per frame"],
        ["Shelf Load Capacity","Up to 500 lbs per shelf"]
      ]},
    { title:"4D Wide Span",
      blurb:"Montelâ€™s 4D Wide Span semi-industrial racking offers the ultimate solution for storing large, heavy items with ease. Engineered for strength and versatility, its robust beams support direct item placement, while optional drop panels transform the structure into sturdy shelving. For enhanced functionality, 4D frames seamlessly integrate with SmartShelf 4-Post accessories, delivering unmatched adaptability to meet your storage needs.",
      img:"assets/pipe3.png", tds:"#",
      specHeaders:["Specification","Capacity"],
      specs:[
        ["Load per Bay","Up to 5,000 lbs per bay (2 268 kg)"],
        ["Load per Level","3\" Beam : 1,000lbs per pair of beam (454 kg)"],
        ["Span","4\" Beam : 1,500 lbs per pair of beam (680 kg)"],
        ["Height","4' to 8' (1.2 m to 2.4 m)"],
        ["Depth","Up to 20' (6.1 m)"]
      ]},
    { title:"SmartSpace",
      blurb:"Montelâ€™s SmartSpace storage system offers a cost-effective and versatile solution for organizing light objects. Designed with efficiency in mind, the SmartSpace system ensures quick and hassle-free installation, helping you save time and reduce expenses. Choose between two tailored options, manual or mechanically assisted, to meet your unique storage requirements with ease and precision.",
      img:"assets/pipe4.png", tds:"#",
      specHeaders:["Specification","Capacity"],
      specs:[
        ["Section Load Capacity","2,000 lbs per section (907 kg)"],
        ["Section Length","24\" to 48\" (0.61m - 1.2m)"],
        ["Section Depth","Panels: 12\" to 48\" (0.3m - 1.2 m); Columns: 18\" to 48\" (0.5m - 1.2m)"],
        ["Carriage Load Capacity","16,000 lbs per carriage (7270kg)"],
        ["Carriage Length","Max 24' (7.3 m)"]
      ]},
    { title:"SmartGlide",
      blurb:`Montelâ€™s SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system that leverages your available space to maximize storage efficiency. Itâ€™s an excellent alternative when space limitations prevent you from using one of our larger mobile systems.

APPLICATION:  Unlike other mobile systems, you do not have to open up an aisle to access your stored material. Just slide the system laterally to reach what you need. This allows you to make full use of your storage space without wasting a square inch.

For high-density storage of relatively small and light items in tight quarters, such as files, boxes, medications, and parts, it's vastly superior to conventional filing and storage systems.`,
      img:"assets/pipe5.png", tds:"#",
      specHeaders:null, specs:[] },
    { title:"GREENRAK",
      blurb:"Montelâ€™s GREENRAKÂ® 2.0 mobile system has been developed specifically for growing applications. Its lightweight, rust-resistant, and simple design allows for easy installation, use, and maintenance.",
      img:"assets/greenrak.png", tds:"#",
      specTable:{ headers:["Specification","Section","Mobile"],
        rows:[
          ["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],
          ["Depth","â€”","36â€, 42â€, 48â€"],
          ["Length","4â€™, 8â€™","Max 50â€™"]
        ]}},
    { title:"Mobilex",
      blurb:"Montel's Mobilex mechanical-assist mobile storage systems provide your organization with the flexibility to customize high-density storage solutions to meet your unique needs. Its innovative mechanism allows for effortless access and mobilization of your items.",
      img:"assets/pipe7.png", tds:"#",
      specHeaders:["Specification","Capacity"],
      specs:[
        ["Load Capacity","1,000 lbs per linear foot (1 488kg/m)"],
        ["Depth","3' to 45' (0.91m - 13.7m)"],
        ["Length","15\" to 48\" (0.4m -2.4 m)"]
      ]},
    { title:"SAFERAK 32P & 60P",
      blurb:"Unlock the full potential of your storage with Montelâ€™s cutting-edge powered mobile racking system. Designed for industrial environments, the SAFERAKÂ® 32P & 60P can handle, respectively, an impressive load capacity of 32,000 lbs and 60,000 lbs per double rack section, optimizing storage efficiency and cutting costs. Embrace the future with smart factory technology, fully equipped for Industry 4.0 to boost your production efficiency and adaptability through seamless digital transformation.",
      img:"assets/pipe8.png", tds:"#",
      specTable:{ headers:["Specification","SAFERAK 32P","SAFERAK 60P"],
        rows:[
          ["Load per Double-Bay","32,000lbs (14 500 kg)","60,000lbs (27 200 kg)"],
          ["Load per Carriage","256,000 lbs (116 000 kg)","480,000 lbs (217 600 kg)"],
          ["Bay Depth","Up to 8' (2.4 m)","Up to 8' (2.4 m)"],
          ["Bay Width","Up to 12' (3.6 m)","Up to 12' (3.6 m)"],
          ["Carriage Length","Up to 100â€™ (30 m)","Up to 120â€™ (36 m)"],
          ["Industrial Safeties","YES","YES"],
          ["PLC","YES","YES"],
          ["Touchscreen UI","YES","YES"],
          ["Signal Strobe and Buzzers","YES","YES"],
          ["VPN eWon Connectivity","YES","YES"],
          ["Rear Controls","Optional","Optional"],
          ["In-Aisle E-Stops","Optional","Optional"],
          ["Illuminated E-Stops","Optional","Optional"]
        ]}}
  ];
  /* ===== End Systems info ===== */

  // Pipes (state) â€” with precomposed sprites
  const pipes=[];
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function buildPipeSprite(sty, top, gap, w){
    const c = document.createElement('canvas');
    c.width = w; c.height = H;
    const g = c.getContext('2d'); g.imageSmoothingEnabled = true;

    // Top segment
    if (top>0){
      const cap = sty.top.cap, body = sty.top.body;
      const capH = Math.min(cap.height, top), bodyH = top - capH;
      // tile body upward
      if (bodyH>0){
        let y = top - capH - body.height;
        while (y >= 0) { g.drawImage(body, 0, y, w, body.height); y -= body.height; }
        const rem = (top - capH) % body.height;
        if (rem > 0) g.drawImage(body, 0, body.height - rem, body.width, rem, 0, 0, w, rem);
      }
      // cap
      g.drawImage(cap, 0, top - capH, w, capH);
    }

    // Bottom segment
    const by = top + gap;
    const bottomH = H - by;
    if (bottomH>0){
      const cap = sty.bottom.cap, body = sty.bottom.body;
      const capH = Math.min(cap.height, bottomH);
      // cap
      g.drawImage(cap, 0, by, w, capH);
      // body tiled downward
      let y = by + capH;
      const remain = bottomH - capH;
      let filled = 0;
      while (filled + body.height <= remain) {
        g.drawImage(body, 0, y, w, body.height);
        y += body.height; filled += body.height;
      }
      const left = remain - filled;
      if (left > 0) g.drawImage(body, 0, 0, body.width, left, 0, y, w, left);
    }

    return c;
  }

  function spawnPipe(){
    if(!Styles.length) return;
    const margin = Math.round(H * 0.10);
    const maxSection = Math.round(H * 0.45);
    const minGapRequired = H - 2*maxSection - 2*margin;
    const minGap = Math.max(GAP_MIN, Math.min(GAP_MAX, Math.max(0, Math.floor(minGapRequired))));
    const gap = randInt(minGap, GAP_MAX);

    let top = randInt(margin, H - gap - margin);
    if (top > maxSection) top = maxSection;
    let bottomH = H - (top + gap);
    if (bottomH > maxSection) top = H - gap - maxSection;
    top = Math.max(margin, Math.min(top, H - gap - margin));

    const styleIndex = Math.floor(Math.random()*Styles.length);
    const sty = Styles[styleIndex];
    const w = sty.drawW;

    const sprite = buildPipeSprite(sty, top, gap, w);
    pipes.push({ x:W, top, gap, w, styleIndex, scored:false, sprite });
  }

  function stepPipes(dt){
    spawnTimer += dt * SPEED_MULT;
    while (spawnTimer >= PIPE_SPAWN_EVERY_S) { spawnPipe(); spawnTimer -= PIPE_SPAWN_EVERY_S; }
    for(const p of pipes){ p.x -= SCROLL_PPS * dt; }
    for(let i=pipes.length-1;i>=0;i--) if(pipes[i].x + pipes[i].w <= 0) pipes.splice(i,1);
  }

  function collideAndScore(leftoverTime){
    const bx1 = bird.x + BIRD_INSET;
    const bx2 = bird.x + bird.w - BIRD_INSET;
    const by1 = bird.yRender - (bird.h/2 - BIRD_INSET);
    const by2 = bird.yRender + (bird.h/2 - BIRD_INSET);

    for(const p of pipes){
      const xR = p.x - SCROLL_PPS * leftoverTime;
      const overlapX = (bx2 > xR) && (bx1 < xR + p.w);
      if (overlapX) {
        const safeTop = p.top - GAP_FORGIVE;
        const safeBottom = p.top + p.gap + GAP_FORGIVE;
        const hitsTop = by1 < safeTop;
        const hitsBottom = by2 > safeBottom;
        if (hitsTop || hitsBottom) { endGame(p.styleIndex); return true; }
      }
      if(!p.scored && (xR+p.w) < bx1){
        p.scored = true;
        score++; scoreEl.textContent = score;
        if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest', String(best)); }
      }
    }
    return false;
  }

  // Drawing
  let bgImg=null, birdImg=null;
  function drawBackground(){ if(bgImg) ctx.drawImage(bgImg,0,0,W,H); else { ctx.fillStyle="#d9f4ff"; ctx.fillRect(0,0,W,H); } }
  function drawPipesInterpolated(leftoverTime){
    for(const p of pipes){
      const xR = p.x - SCROLL_PPS * leftoverTime;
      ctx.drawImage(p.sprite, xR, 0, p.w, H);
    }
  }

  // Bird
  const bird={
    x:Math.round(W*0.167),
    y:Math.round(H*0.5),
    w:Math.round(H*0.069),
    h:Math.round(H*0.069),
    v:0,
    yRender:0,
    draw(){
      ctx.save();
      const a=Math.max(-0.45,Math.min(0.9,(this.v/600)*0.5));
      ctx.translate(this.x+this.w/2,this.yRender);
      ctx.rotate(a);
      if(birdImg){ ctx.drawImage(birdImg,-this.w/2,-this.h/2,this.w,this.h); }
      else { ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h); }
      ctx.restore();
    },
    step(dt){ this.v += G * dt; if (this.v > MAX_FALL) this.v = MAX_FALL; this.y += this.v * dt; },
    flap(){ this.v = LIFT_V0; },
    reset(){ this.y=Math.round(H*0.5); this.v=0; }
  };

  // Adaptive semi-fixed timestep with interpolation
  let physicsHz = 120;               // default
  let STEP = 1/physicsHz;
  const MAX_FRAME_DT = 0.12;
  let accumulator = 0, lastTs = performance.now();

  // Calibrate refresh rate from first frames
  const samples=[]; const targetRates=[60,90,100,120,144,165,180,240];
  function calibrate(dt){
    if (samples.length<30){ samples.push(dt); return; }
    const avg = samples.reduce((a,b)=>a+b,0)/samples.length;
    const estHz = Math.round(1/avg);
    let nearest = targetRates[0], bestDiff=1e9;
    for(const r of targetRates){ const d=Math.abs(estHz - r); if(d<bestDiff){ bestDiff=d; nearest=r; } }
    physicsHz = (nearest<=60)?120:Math.min(nearest,240); // 60Hz -> 120Hz physics; hi-Hz -> native (cap 240)
    STEP = 1/physicsHz;
    samples.length=30; // lock
  }

  function loop(ts){
    let frameDt = (ts - lastTs) / 1000;
    if (frameDt > MAX_FRAME_DT) frameDt = MAX_FRAME_DT;
    if (frameDt < 0) frameDt = 0;
    if (samples.length<30) calibrate(frameDt);
    lastTs = ts;

    accumulator += frameDt;
    while (accumulator >= STEP) {
      if(started && !over){
        stepPipes(STEP);
        bird.step(STEP);
        if(bird.y + (bird.h - BIRD_INSET) >= H) endGame(null);
        if(bird.y + BIRD_INSET <= 0) endGame(null);
      }
      accumulator -= STEP;
    }
    let leftover = accumulator; // 0..STEP

    /* === SHAKE FIX ===
       When over==true, do NOT apply interpolation offsets.
       Freeze render positions to exact last-simulated states. */
    if (over) leftover = 0;

    // Render
    ctx.clearRect(0,0,W,H);
    drawBackground();

    // Predict bird render pos using leftover (or 0 when over)
    bird.yRender = bird.y + bird.v * leftover + (over ? 0 : 0.5 * G * leftover * leftover);
    drawPipesInterpolated(leftover);
    bird.draw();

    // collision/score only when playing
    if(started && !over){ collideAndScore(leftover); }

    // version label
    ctx.fillStyle='rgba(0,0,0,.95)';
    ctx.font='700 16px Montserrat,system-ui';
    ctx.fillText('v'+VERSION, 14, H-14);

    requestAnimationFrame(loop);
  }

  // Game Over system box
  function endGame(hitStyleIdx){
    if(over) return;
    over=true;

    // Snap physics so nothing drifts
    bird.v = 0;

    finalScoreP.textContent = `Score: ${score} â€¢ Best: ${best}`;

    const box   = document.getElementById('sysInfoBox');
    const imgEl = document.getElementById('sysImg');
    const tEl   = document.getElementById('sysTitle');
    const bEl   = document.getElementById('sysBlurb');
    const specsBox = document.getElementById('sysSpecsBox');
    const sEl   = document.getElementById('sysSpecs');
    const lEl   = document.getElementById('sysLinks');

    if (hitStyleIdx!=null && SYSTEMS[hitStyleIdx]){
      const info = SYSTEMS[hitStyleIdx];
      tEl.textContent = info.title || `System ${hitStyleIdx+1}`;
      bEl.textContent = info.blurb || '';
      lEl.innerHTML   = info.tds && info.tds !== '#'
        ? `<a href="${info.tds}" target="_blank" rel="noopener" style="color:#7dcfff;text-decoration:underline">ðŸ“„ Technical Data Sheet</a>` : '';

      if(info.img && info.img !== '#'){
        imgEl.style.opacity = '0';
        imgEl.onload = ()=>{ imgEl.style.opacity = '1'; };
        imgEl.src = info.img;
        imgEl.style.display = 'block';
      } else { imgEl.style.display = 'none'; }

      // Table or 2-col specs
      sEl.innerHTML = '';
      if (info.specTable && Array.isArray(info.specTable.headers) && Array.isArray(info.specTable.rows)) {
        const headers = info.specTable.headers;
        sEl.innerHTML = '<thead><tr>' + headers.map(h=>`<th>${h}</th>`).join('') + '</tr></thead><tbody></tbody>';
        const tbody = sEl.querySelector('tbody');
        info.specTable.rows.forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = row.map((cell,i)=>`<td${i===0?' style="font-weight:600"':''}>${cell}</td>`).join('');
          tbody.appendChild(tr);
        });
        specsBox.style.display = 'block';
      } else if (info.specHeaders && info.specs && info.specs.length){
        sEl.innerHTML = '<thead><tr>' + info.specHeaders.map(h=>`<th>${h}</th>`).join('') + '</tr></thead><tbody></tbody>';
        const tbody = sEl.querySelector('tbody');
        info.specs.forEach(([k,v])=>{
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="font-weight:600">${k}</td><td>${v}</td>`;
          tbody.appendChild(tr);
        });
        specsBox.style.display = 'block';
      } else {
        specsBox.style.display = 'none';
      }
      box.style.display = 'block';
    } else {
      box.style.display = 'none';
      imgEl.style.display = 'none';
    }

    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop = 0; requestAnimationFrame(()=>{ gameOverCard.scrollTop = 0; });
    restartLocked = true; setTimeout(()=>{ restartLocked=false; }, 1000);
  }

  function startGame(){
    started=true; over=false; restartLocked=false; spawnTimer=0;
    lastScore = score; lastEl.textContent = lastScore;
    score = 0; scoreEl.textContent = "0";
    pipes.length = 0; bird.reset();
    startCard.classList.add('hidden');
    gameOverCard.classList.add('hidden');
  }

  function handleTap(e){
    e?.preventDefault?.(); e?.stopPropagation?.();
    initAudioOnce().then(()=>{ try{ audioCtx.resume(); }catch(_){} setMuted(muted); }).catch(()=>{});
    if(!rotBlock.classList.contains('show')){
      if(!started){ startGame(); bird.flap(); return; }
      if(!over){ bird.flap(); return; }
      if(!restartLocked) startGame();
    }
  }
  startCard.addEventListener('click', handleTap, {passive:false});
  startCard.addEventListener('touchstart', handleTap, {passive:false});
  document.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('#gameOverCard')) return;
    if (e.target.closest('#muteBtn, #fsBtn')) return;
    handleTap(e);
  }, {passive:false, capture:true});
  document.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.key===' ') handleTap(e); }, {passive:false});

  // Boot (inline, no external script)
  (async () => {
    try{
      const [bg,birdPic] = await Promise.all([
        loadImageWithTimeout("assets/bg.png"),
        loadImageWithTimeout("assets/bird.png")
      ]);
      bgImg = bg || null; birdImg = birdPic || null;

      const promises = [];
      for (const s of PIPE_STYLES_CFG){
        promises.push(loadImageWithTimeout(s.bottom.url));
        promises.push(loadImageWithTimeout(s.top.url));
      }
      const results = await Promise.allSettled(promises);
      const bottoms=[], tops=[];
      for (let i=0;i<PIPE_STYLES_CFG.length;i++){
        bottoms[i] = results[i*2]?.value || null;
        tops[i]    = results[i*2+1]?.value || null;
      }
      Raw.bottoms = bottoms; Raw.tops = tops;
      rebuildStyles();
    } finally {
      document.getElementById('loadingOverlay').style.display='none';
      requestAnimationFrame(loop);
    }
  })();

})(); // IIFE
</script>
</body>
</html>
