<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flappy Mo — Local Assets (v1.48f-rocket-teardrop)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  /* Logical canvas 1920×1080; CSS scales for fit (keeps motion smooth) */
  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
  }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
    scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff; }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff; }
  .hidden{ display:none }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:999 }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  #sysImg {
    max-width:100%; max-height:240px; object-fit:contain;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.1);
    border-radius:10px; margin:10px auto; /* center on card */
    display:none; opacity:0; transition:opacity .25s ease;
  }
  #sysInfoBox, #sysInfoBox * { color:#fff !important; }
  #sysBlurb { white-space:pre-line; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">🔊 Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">⛶ Fullscreen</button>

<!-- Overlays -->
<div class="overlay">
  <div id="startCard" class="card">
    <h1>Tap to Start</h1>
    <p>Tap again to flap • Best is saved</p>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 • Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>

    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">—</span></div>
      <div id="sysBlurb" style="opacity:.95; font-size:13px; margin-bottom:8px">—</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<!-- Rotate blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. Turn your device to play.</p>
  </div>
</div>

<script>
(() => {
  const VERSION = '1.48f-rocket-teardrop';
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  // WORLD
  const W = 1920, H = 1080;

  // Physics
  const SPEED_MULT = isMobile ? 1.40 : 1.50;
  const G         = 4800 * SPEED_MULT;
  const LIFT_V0   = -1350 * SPEED_MULT;
  const MAX_FALL  = 2200 * SPEED_MULT;
  const SCROLL_PPS=  480 * SPEED_MULT;

  // Pipes
  const PIPE_W    = 180;
  const GAP_MIN   = 310, GAP_MAX = 450;

  // Vertical spacing
  const VERTICAL_X_GAP = Math.round(SCROLL_PPS * 1.8);
  const FIRST_VERTICAL_LEAD_PIXELS = VERTICAL_X_GAP;

  // Horizontal challenge (after each 10 verticals)
  const CHALLENGE_BARS   = 3;
  const HORIZ_SPACING_X  = Math.round(W * 0.25);
  const HORIZ_MARGIN_Y   = Math.round(H * 0.18);
  const BUFFER_PIXELS    = Math.round(W * 0.06);  // (your chosen 6%)
  const HORIZ_LEAD_PIXELS= Math.round(W * 0.08);

  // Top & bottom grace (keep your tuned values)
  const TOP_OVERLAP_FRAC    = 0.30;
  const BOTTOM_OVERLAP_FRAC = 0.75;

  // -------- Rocket Flame: premium teardrop with shock diamonds --------
  // Requirements: narrow to the LEFT (tail), widest at nozzle near bird.
  const FLAME = {
    lenFrac: 1.00,        // len ≈ bird.w
    nozzleHalfFrac: 0.30, // width at nozzle (× bird.h) -> hotter/wider near bird
    tailHalfFrac: 0.05,   // narrow at tail (left)
    offsetFrac: 0.50,     // how far behind bird center nozzle starts
    coreAlpha: 1.00,
    glowAlpha: 0.70,
    shimmerAmp: 0.035,    // subtle width modulation
    flickerAmp: 0.05,     // length/intensity flicker
    flapBoostDur: 0.22,
    diamonds: [0.22, 0.46, 0.70], // along length (0..1)
  };
  let flapBoostTimer = 0;
  let tNow = 0;

  // Flow / phases
  let phase = 'VERTICALS';
  let bufferTime = 0;
  let challengeQueued = false;
  let verticalsPassed = 0;
  let nextSpawnPx = FIRST_VERTICAL_LEAD_PIXELS;
  let verticalsEnabled = true;

  // Canvas fit (CSS scale only)
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = true;

  function fitCSS(){
    const vw = innerWidth;
    const vh = Math.round(window.visualViewport ? visualViewport.height : innerHeight);
    const s = Math.min(vw / W, vh / H);
    canvas.style.transform = `translate(-50%, -50%) scale(${s})`;
  }
  addEventListener('resize', fitCSS, {passive:true});
  window.visualViewport && visualViewport.addEventListener('resize', fitCSS, {passive:true});
  fitCSS();

  // Orientation
  const rotBlock = document.getElementById('rotBlock');
  function checkOrientation(){ rotBlock.classList.toggle('show', innerWidth < innerHeight); }
  addEventListener('resize', checkOrientation, {passive:true}); checkOrientation();

  // UI
  const scoreEl = document.getElementById('scoreVal');
  const lastEl  = document.getElementById('lastVal');
  const bestEl  = document.getElementById('bestVal');
  const startCard   = document.getElementById('startCard');
  const gameOverCard= document.getElementById('gameOverCard');
  const finalScoreP = document.getElementById('finalScoreP');
  const fsBtn = document.getElementById('fsBtn');

  function inFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
  function updateFsBtn(){ fsBtn.textContent = inFullscreen() ? "⤢ Exit" : "⛶ Fullscreen"; }
  fsBtn.addEventListener('click', async (e)=>{
    e.stopPropagation();
    const el=document.documentElement;
    try{
      if(!inFullscreen()){
        await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.msRequestFullscreen?.());
      } else {
        await (document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.msExitFullscreen?.());
      }
    }catch(_){}
    updateFsBtn();
  }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  // Scores/state
  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent = best;

  // AUDIO (flap + hit only — no score sound)
  let audioCtx=null, masterGain=null, audioReady=false, muted=false;
  function createAudio(){ if(audioReady) return; const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return; audioCtx=new AC({latencyHint:"interactive"}); masterGain=audioCtx.createGain(); masterGain.gain.value=muted?0:0.85; masterGain.connect(audioCtx.destination); audioReady=true; }
  async function unlockAudio(){ try{ createAudio(); if(audioCtx && audioCtx.state!=='running'){ await audioCtx.resume(); } }catch(_){ } }
  function setMuted(m){ muted=m; if(masterGain) masterGain.gain.value=muted?0:0.85; const b=document.getElementById('muteBtn'); b.textContent = muted ? "🔇 Muted" : "🔊 Sound"; b.setAttribute("aria-pressed", String(muted)); }
  document.getElementById('muteBtn').addEventListener('click', async (e)=>{ e.stopPropagation(); await unlockAudio(); setMuted(!muted); });
  function envGain(d=0.25,a=0.008,v=1){ if(!audioReady) return null; const g=audioCtx.createGain(); const t=audioCtx.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.exponentialRampToValueAtTime(0.0001,t+d); return g; }
  function woosh(d=0.22,c=1200,v=0.35){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<n;i++) data[i]=(Math.random()*2-1)*0.35; const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=c; const g=envGain(d,0.01,v); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  function crash(d=1.1){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); let b0=0,b1=0,b2=0; for(let i=0;i<n;i++){ const w=Math.random()*2-1; b0=0.997*b0+w*0.03; b1=0.985*b1+w*0.05; b2=0.95*b2+w*0.07; data[i]=(b0+b1+b2)*0.65; } const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=700; const g=envGain(d,0.02,0.45); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  const playFlap = ()=> woosh();
  const playHit  = ()=> crash();

  // Assets
  function loadImageWithTimeout(src,timeout=6000){ return new Promise((res)=>{ if(!src){ res(null); return; } const img=new Image(); img.referrerPolicy='no-referrer'; let done=false; const finish=v=>{ if(done)return; done=true; res(v||null); }; const t=setTimeout(()=>finish(null),timeout); img.onload=()=>{ clearTimeout(t); finish(img); }; img.onerror=()=>{ clearTimeout(t); finish(null); }; img.src=src; }); }

  // Bird sprite support
  const BIRD_SPRITE_FRAMES = 4;
  const BIRD_SPRITE_FPS    = 10;
  let birdSprite=null, birdFallbackImg=null, bgImg=null;

  // Pipe styles
  const PIPE_STYLES_CFG = [
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] };
  const Styles=[];
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#3a3a3a"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.imageSmoothingEnabled=true; g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return { cap:ph, body:ph }; }
    const scale = drawW / (img.naturalWidth || img.width);
    const scaledH = Math.max(1, Math.round((img.naturalHeight || img.height) * scale));
    const capH    = Math.max(1, Math.round(capPxSrc * scale));
    const full = makeScaledCanvas(img, drawW, scaledH);
    const cap  = document.createElement("canvas");
    const body = document.createElement("canvas");
    cap.width = drawW; cap.height = Math.min(capH, scaledH);
    body.width = drawW; body.height = Math.max(1, scaledH - cap.height);
    const cg = cap.getContext("2d"), bg = body.getContext("2d");
    cg.imageSmoothingEnabled = bg.imageSmoothingEnabled = true;
    if (capFrom === "top") {
      cg.drawImage(full, 0, 0, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, cap.height, drawW, body.height, 0, 0, drawW, body.height);
    } else {
      cg.drawImage(full, 0, scaledH - cap.height, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, 0, drawW, body.height, 0, 0, drawW, body.height);
    }
    return { cap, body };
  }
  function rebuildStyles(){
    Styles.length=0;
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      const cfg=PIPE_STYLES_CFG[i];
      const bot=Raw.bottoms[i], top=Raw.tops[i];
      const drawW = Math.round(PIPE_W * (cfg.scale || 1));
      const bottom = buildCapBodyPx(bot, drawW, cfg.bottom.capPx, cfg.bottom.capFrom);
      const topset = buildCapBodyPx(top, drawW, cfg.top.capPx,   cfg.top.capFrom);
      Styles.push({ name:cfg.name, bottom, top:topset, drawW, botImg: bot });
    }
  }

  // ---------- SYSTEM INFO ----------
  const SYSTEMS = [
    { title: "EATNASTAK (DOUBLE FACE)",
      blurb: `When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system
offers unmatched flexibility, allowing you to reconfigure it as often as needed to suit your evolving preferences. Whether expanding
your collection or rearranging your space, Aetnastak provides the adaptability and reliability you need for efficient and organized
library management.`,
      img: "assets/pipe1.png", tds: "#",
      specHeaders: ["Specification","Standard Dimensions"],
      specs: [
        ["Width","24, 30, 36\""],
        ["Depth","7, 8, 9, 10, 11, 12, 13, 14, 15, 16\""],
        ["Height","30, 31, …, 108\""],
        ["Shelf Load Capacity","Up to 50 psf"]
      ]
    },
    { title: "SMARTSHELF (FIXED, FULL DEPTH)",
      blurb: "Montel's patented SmartShelf is the most versatile storage shelving system available today. This innovative 4-post shelving offers complete flexibility, accommodating items of all shapes and sizes. It is also designed for easy assembly and reconfiguration.",
      img: "assets/pipe2.png", tds: "#",
      specHeaders: ["Specification","Standard Dimensions"],
      specs: [
        ["Width","24, 30, 36, 1M, 42, 48, 54\""],
        ["Depth","12, 13, 15, 16, 18, 20, 24, 30, 36\""],
        ["Height","30, 31, …, 120\""],
        ["Frame Load Capacity","Up to 2,500 lbs per frame"],
        ["Shelf Load Capacity","Up to 500 lbs per shelf"]
      ]
    },
    { title: "4D Wide Span",
      blurb: "Montel’s 4D Wide Span semi-industrial racking offers the ultimate solution for storing large, heavy items with ease. Engineered for strength and versatility, its robust beams support direct item placement, while optional drop panels transform the structure into sturdy shelving. For enhanced functionality, 4D frames seamlessly integrate with SmartShelf 4-Post accessories, delivering unmatched adaptability to meet your storage needs.",
      img: "assets/pipe3.png", tds: "#",
      specHeaders: ["Specification","Capacity"],
      specs: [
        ["Load per Bay","Up to 5,000 lbs per bay (2 268 kg)"],
        ["Load per Level","3\" Beam : 1,000lbs per pair of beam (454 kg)"],
        ["Span","4\" Beam : 1,500 lbs per pair of beam (680 kg)"],
        ["Height","4' to 8' (1.2 m - 2.4 m)"],
        ["Depth","Up to 20' (6.1 m)"]
      ]
    },
    { title: "SmartSpace",
      blurb: "Montel’s SmartSpace storage system offers a cost-effective and versatile solution for organizing light objects. Designed with efficiency in mind, the SmartSpace system ensures quick and hassle-free installation, helping you save time and reduce expenses. Choose between two tailored options, manual or mechanically assisted, to meet your unique storage requirements with ease and precision.",
      img: "assets/pipe4.png", tds: "#",
      specHeaders: ["Specification","Capacity"],
      specs: [
        ["Section Load Capacity","2,000 lbs per section (907 kg)"],
        ["Section Length","24\" to 48\" (0.61m - 1.2m)"],
        ["Section Depth","Panels: 12\" to 48\" (0.3m - 1.2 m)\nColumns: 18\" to 48\" (0.5m - 1.2m)"],
        ["Carriage Load Capacity","16,000 lbs per carriage (7270kg)"],
        ["Carriage Length","Max 24' (7.3 m)"]
      ]
    },
    { title: "SmartGlide",
      blurb: `Montel’s SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system that leverages your available space to maximize storage efficiency. It’s an excellent alternative when space limitations prevent you from using one of our larger mobile systems.

APPLICATION: 	Unlike other mobile systems, you do not have to open up an aisle to access your stored material. Just slide the system laterally to reach what you need. This allows you to make full use of your storage space without wasting a square inch.

For high-density storage of relatively small and light items in tight quarters, such as files, boxes, medications, and parts, it's vastly superior to conventional filing and storage systems.`,
      img: "assets/pipe5.png", tds: "#",
      specHeaders: null, specs: []
    },
    { title: "GREENRAK",
      blurb: "Montel’s GREENRAK® 2.0 mobile system has been developed specifically for growing applications. Its lightweight, rust-resistant, and simple design allows for easy installation, use, and maintenance.",
      img: "assets/greenrak.png", tds: "#",
      specTable: {
        headers: ["Specification","Section","Mobile"],
        rows: [
          ["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],
          ["Depth","—-------------","36”, 42”, 48”"],
          ["Length","4’, 8’","Max 50’"]
        ]
      }
    },
    { title: "Mobilex",
      blurb: "Montel's Mobilex mechanical-assist mobile storage systems provide your organization with the flexibility to customize high-density storage solutions to meet your unique needs. Its innovative mechanism allows for effortless access and mobilization of your items.",
      img: "assets/pipe7.png", tds: "#",
      specHeaders: ["Specification","Capacity"],
      specs: [
        ["Load Capacity","1,000 lbs per linear foot (1 488kg/m)"],
        ["Depth","3' to 45' (0.91m - 13.7m)"],
        ["Length","15\" to 48\" (0.4m -2.4 m)"]
      ]
    },
    { title: "SAFERAK 32P & 60P",
      blurb: "Unlock the full potential of your storage with Montel’s cutting-edge powered mobile racking system. Designed for industrial environments, the SAFERAK® 32P & 60P can handle, respectively, an impressive load capacity of 32,000 lbs and 60,000 lbs per double rack section, optimizing storage efficiency and cutting costs. Embrace the future with smart factory technology, fully equipped for Industry 4.0 to boost your production efficiency and adaptability through seamless digital transformation.",
      img: "assets/pipe8.png", tds: "#",
      specTable: {
        headers: ["Specification","SAFERAK 32P","SAFERAK 60P"],
        rows: [
          ["Load per Double-Bay","32,000lbs (14 500 kg)","60,000lbs (27 200 kg)"],
          ["Load per Carriage","256,000 lbs (116 000 kg)","480,000 lbs (217 600 kg)"],
          ["Bay Depth","Up to 8' (2.4 m)","Up to 8' (2.4 m)"],
          ["Bay Width","Up to 12' (3.6 m)","Up to 12' (3.6 m)"],
          ["Carriage Length","Up to 100’ (30 m)","Up to 120’ (36 m)"],
          ["Industrial Safeties","YES","YES"],
          ["PLC","YES","YES"],
          ["Touchscreen UI","YES","YES"],
          ["Signal Strobe and Buzzers","YES","YES"],
          ["VPN eWonConnectivity","YES","YES"],
          ["Rear Controls","Optional","Optional"],
          ["In-Aisle E-Stops","Optional","Optional"],
          ["Illuminated E-Stops","Optional","Optional"]
        ]
      }
    }
  ];

  /* ----------------- OBSTACLES ----------------- */
  const obstacles=[];
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function buildVerticalSprite(sty, top, gap, w){
    const c=document.createElement('canvas'); c.width=w; c.height=H;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(top>0){
      const cap=sty.top.cap, body=sty.top.body;
      const capH=Math.min(cap.height,top), bodyH=top-capH;
      if(bodyH>0){
        let y=top-capH-body.height;
        while(y>=0){ g.drawImage(body,0,y,w,body.height); y-=body.height; }
        const rem=(top-capH)%body.height;
        if(rem>0) g.drawImage(body,0,body.height-rem,body.width,rem,0,0,w,rem);
      }
      g.drawImage(cap,0,top-capH,w,capH);
    }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){
      const cap=sty.bottom.cap, body=sty.bottom.body;
      const capH=Math.min(cap.height,bottomH);
      g.drawImage(cap,0,by,w,capH);
      let y=by+capH, filled=0, remain=bottomH-capH;
      while(filled+body.height<=remain){ g.drawImage(body,0,y,w,body.height); y+=body.height; filled+=body.height; }
      const left=remain-filled;
      if(left>0) g.drawImage(body,0,0,body.width,left,0,y,w,left);
    }
    return c;
  }

  function buildHorizontalSprite(sty){
    const img=sty.botImg;
    const drawW=sty.drawW;
    const c=document.createElement('canvas'); c.width=Math.max(1, drawW*6); c.height=drawW;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(img){
      const scale=drawW/(img.naturalWidth||img.width);
      const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
      c.width=scaledH; c.height=drawW;
      g.translate(0,drawW); g.rotate(-Math.PI/2);
      g.drawImage(img,0,0,img.naturalWidth||img.width,img.naturalHeight||img.height,0,0,drawW,scaledH);
    }else{
      g.fillStyle="#2e8b57"; g.fillRect(0,0,c.width,c.height);
    }
    return c;
  }

  function spawnVerticalAt(xPos){
    if(!Styles.length) return;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin, minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin); if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap); if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex], w=sty.drawW;
    const sprite=buildVerticalSprite(sty,top,gap,w);
    obstacles.push({type:'V',x:xPos,top,gap,w,styleIndex,scored:false,sprite});
  }
  const spawnVertical=()=>spawnVerticalAt(W);

  function spawnHorizontalAt(xStart){
    if(!Styles.length) return;
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex];
    const sprite=buildHorizontalSprite(sty);
    const w=sprite.width, h=sty.drawW, y=randInt(HORIZ_MARGIN_Y,H-HORIZ_MARGIN_Y-h);
    obstacles.push({type:'H',x:xStart,y,w,h,styleIndex,scored:false,sprite});
  }
  function spawnHorizontalChallenge(){
    const firstX = W + HORIZ_LEAD_PIXELS;
    let lastRight=0;
    for(let i=0;i<CHALLENGE_BARS;i++){
      const x=(i===0?firstX:lastRight+HORIZ_SPACING_X);
      spawnHorizontalAt(x);
      const last=obstacles[obstacles.length-1];
      lastRight = last.x + last.w;
    }
  }

  function stepObstacles(dt){
    for(const o of obstacles){ o.x -= SCROLL_PPS*dt; }
    for(let i=obstacles.length-1;i>=0;i--) if(obstacles[i].x+obstacles[i].w<=0) obstacles.splice(i,1);

    if(phase==='VERTICALS'){
      if(verticalsEnabled){
        nextSpawnPx -= SCROLL_PPS * dt;
        while(nextSpawnPx <= 0){ spawnVertical(); nextSpawnPx += VERTICAL_X_GAP; }
      }
      if(challengeQueued){
        phase='PRE_BUFFER'; verticalsEnabled=false;
        nextSpawnPx = VERTICAL_X_GAP;
        bufferTime = BUFFER_PIXELS / SCROLL_PPS;
        challengeQueued=false;
      }
      return;
    }
    if(phase==='PRE_BUFFER'){ bufferTime -= dt; if(bufferTime<=0){ phase='H_CHALLENGE'; spawnHorizontalChallenge(); } return; }
    if(phase==='H_CHALLENGE'){ if(obstacles.findIndex(o=>o.type==='H')===-1){ phase='POST_BUFFER'; bufferTime = BUFFER_PIXELS / SCROLL_PPS; } return; }
    if(phase==='POST_BUFFER'){ bufferTime -= dt; if(bufferTime<=0){ phase='VERTICALS'; verticalsEnabled=true; } return; }
  }

  function scoreUp(){ score++; scoreEl.textContent=score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); } }

  function collideAndScore(leftover){
    const BIRD_INSET = 8, GAP_FORGIVE = 12;
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.type==='V'){
        const overlapX=(bx2>xR)&&(bx1<xR+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){ endGame(o.styleIndex); return true; }
        }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); verticalsPassed++; if(verticalsPassed>0 && verticalsPassed%10===0){ if(phase==='VERTICALS') challengeQueued=true; } }
      } else {
        const overlapX=(bx2>xR)&&(bx1<xR+o.w), overlapY=(by2>o.y)&&(by1<o.y+o.h);
        if(overlapX && overlapY){ endGame(o.styleIndex); return true; }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); }
      }
    }
    return false;
  }

  function drawObstaclesInterpolated(leftover){
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.sprite) ctx.drawImage(o.sprite, xR, (o.type==='H'?o.y:0), o.w, (o.type==='H'?o.h:H));
    }
  }

  // Background (yellow default to ensure contrast if bg missing)
  function drawBackground(){ if(bgImg) ctx.drawImage(bgImg,0,0,W,H); else { ctx.fillStyle="#ffe77a"; ctx.fillRect(0,0,W,H); } }

  // --------- ROCKET FLAME (teardrop with diamonds) ----------
  function drawFlame(){
    if(!started || over) return;

    // Direction vectors from bird angle
    const ang = bird.computeAngle();
    const fwdX = Math.cos(ang), fwdY = Math.sin(ang);        // forward (nose, to the right)
    const rightX = -Math.sin(ang), rightY = Math.cos(ang);   // +90°

    // Nozzle position: behind bird center
    const centerX = bird.x + bird.w/2;
    const centerY = bird.yRender;
    const nozzleX = centerX - fwdX * (bird.w * FLAME.offsetFrac);
    const nozzleY = centerY - fwdY * (bird.w * FLAME.offsetFrac);

    // Dynamics
    const riseFactor = Math.max(0, Math.min(1, (-bird.v)/900)); // stronger when rising
    const boost = Math.max(0, Math.min(1, flapBoostTimer / FLAME.flapBoostDur));
    tNow += 1/60;

    const flick = 1 + FLAME.flickerAmp * Math.sin(tNow * 80 + boost*6);
    const len = bird.w * FLAME.lenFrac * (0.95 + 0.45*riseFactor + 0.50*boost) * flick;

    // Tail (left/back)
    const tailX = nozzleX - fwdX * len;
    const tailY = nozzleY - fwdY * len;

    // Widths (wide at nozzle, narrow at tail)
    const wNoz = bird.h * FLAME.nozzleHalfFrac * (1 + 0.18*riseFactor + 0.25*boost);
    const wTailBase = bird.h * FLAME.tailHalfFrac;
    const shimmer = 1 + FLAME.shimmerAmp * Math.sin(tNow * 50);

    const wTail = wTailBase * shimmer;

    // Quadratic-teardrop outline (glow first, then core)
    const midX = (nozzleX + tailX) * 0.5;
    const midY = (nozzleY + tailY) * 0.5;
    const ctrlPush = wNoz * 0.65; // how round the belly is

    const prevComp = ctx.globalCompositeOperation;

    // --- Outer Glow (additive) ---
    ctx.globalCompositeOperation = "lighter";
    const ga = FLAME.glowAlpha;
    const glowGrad = ctx.createLinearGradient(nozzleX,nozzleY,tailX,tailY);
    glowGrad.addColorStop(0.00, `rgba(255,230,140,${ga*0.95})`);
    glowGrad.addColorStop(0.45, `rgba(255,150,60,${ga*0.75})`);
    glowGrad.addColorStop(1.00, `rgba(255,40,25,${ga*0.55})`);

    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    // start right edge at nozzle (upper)
    ctx.moveTo(nozzleX + rightX*wNoz*1.35, nozzleY + rightY*wNoz*1.35);
    // curve to tail (upper edge)
    ctx.quadraticCurveTo(
      midX + rightX*ctrlPush*1.35, midY + rightY*ctrlPush*1.35,
      tailX + rightX*wTail*1.3,    tailY + rightY*wTail*1.3
    );
    // line across tail to lower edge
    ctx.lineTo(tailX - rightX*wTail*1.3, tailY - rightY*wTail*1.3);
    // curve back to nozzle (lower edge)
    ctx.quadraticCurveTo(
      midX - rightX*ctrlPush*1.35, midY - rightY*ctrlPush*1.35,
      nozzleX - rightX*wNoz*1.35,  nozzleY - rightY*wNoz*1.35
    );
    ctx.closePath();
    ctx.fill();

    // --- Core (non-additive, white-hot interior) ---
    const coreGrad = ctx.createLinearGradient(nozzleX,nozzleY,tailX,tailY);
    coreGrad.addColorStop(0.00, `rgba(255,255,255,${FLAME.coreAlpha})`);
    coreGrad.addColorStop(0.38, `rgba(255,240,130,${FLAME.coreAlpha*0.98})`);
    coreGrad.addColorStop(1.00, `rgba(255,180,60,${FLAME.coreAlpha*0.85})`);

    ctx.globalCompositeOperation = prevComp;
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.moveTo(nozzleX + rightX*wNoz*0.85, nozzleY + rightY*wNoz*0.85);
    ctx.quadraticCurveTo(
      midX + rightX*ctrlPush*0.85, midY + rightY*ctrlPush*0.85,
      tailX + rightX*wTail*0.7,    tailY + rightY*wTail*0.7
    );
    ctx.lineTo(tailX - rightX*wTail*0.7, tailY - rightY*wTail*0.7);
    ctx.quadraticCurveTo(
      midX - rightX*ctrlPush*0.85, midY - rightY*ctrlPush*0.85,
      nozzleX - rightX*wNoz*0.85,  nozzleY - rightY*wNoz*0.85
    );
    ctx.closePath();
    ctx.fill();

    // --- Shock diamonds (tiny hot pulses along centerline) ---
    ctx.globalCompositeOperation = "lighter";
    for(const s of FLAME.diamonds){
      const cx = nozzleX*(1-s) + tailX*s;
      const cy = nozzleY*(1-s) + tailY*s;
      const size = (wNoz*0.33)*(1 - s*0.7) * (1 + 0.25*boost);
      const radGrad = ctx.createRadialGradient(cx,cy,0, cx,cy,size);
      const pulse = 0.65 + 0.35*Math.sin(tNow*70 + s*8 + boost*10);
      radGrad.addColorStop(0.00, `rgba(255,255,255,${0.95*pulse})`);
      radGrad.addColorStop(0.35, `rgba(255,240,140,${0.75*pulse})`);
      radGrad.addColorStop(1.00, `rgba(255,100,20,${0.35*pulse})`);
      ctx.fillStyle = radGrad;
      ctx.beginPath();
      ctx.ellipse(cx, cy, size, size*0.72, ang, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = prevComp;

    // decay boost timer
    if (flapBoostTimer > 0) {
      flapBoostTimer = Math.max(0, flapBoostTimer - 1/120);
    }
  }

  // Bird (sprite sheet with fallback)
  const bird={
    x:Math.round(W*0.167), y:Math.round(H*0.5),
    w:Math.round(H*0.069), h:Math.round(H*0.069),
    v:0, yRender:0, animTime:0,
    angle:0,
    computeAngle(){ this.angle = Math.max(-0.45, Math.min(0.9, (this.v/600)*0.5)); return this.angle; },
    draw(frameDt){
      const ang = this.computeAngle();
      this.animTime += frameDt;
      ctx.save();
      ctx.translate(this.x+this.w/2, this.yRender);
      ctx.rotate(ang);
      if (birdSprite && birdSprite.complete && birdSprite.naturalWidth) {
        const frames=BIRD_SPRITE_FRAMES, fps=BIRD_SPRITE_FPS;
        const frameW=Math.floor(birdSprite.naturalWidth/frames), frameH=birdSprite.naturalHeight;
        const idx=Math.floor(this.animTime*fps)%frames, sx=idx*frameW;
        ctx.drawImage(birdSprite, sx,0,frameW,frameH, -this.w/2,-this.h/2, this.w,this.h);
      } else if (birdFallbackImg && birdFallbackImg.complete && birdFallbackImg.naturalWidth) {
        ctx.drawImage(birdFallbackImg, -this.w/2, -this.h/2, this.w, this.h);
      } else {
        ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);
      }
      ctx.restore();
    },
    step(dt){ this.v+=G*dt; if(this.v>MAX_FALL) this.v=MAX_FALL; this.y+=this.v*dt; },
    flap(){ this.v=LIFT_V0; playFlap(); flapBoostTimer = FLAME.flapBoostDur; },
    reset(){ this.y=Math.round(H*0.5); this.v=0; this.animTime=0; this.angle=0; }
  };

  // Semi-fixed timestep + interpolation (smooth at 60Hz+)
  let physicsHz=120, STEP=1/physicsHz, accumulator=0, lastTs=performance.now();
  const MAX_FRAME_DT=0.12;

  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT) frameDt=MAX_FRAME_DT; if(frameDt<0) frameDt=0; lastTs=ts;

    accumulator += frameDt;
    while(accumulator>=STEP){
      if(started && !over){
        stepObstacles(STEP);
        bird.step(STEP);

        // Top/bottom grace
        const INSET = 8;
        bird.yRender = bird.y;
        const topAllowancePx = bird.h * TOP_OVERLAP_FRAC;
        if(bird.yRender - (bird.h/2 - INSET) <= -topAllowancePx) endGame(null);
        const bottomAllowancePx = bird.h * BOTTOM_OVERLAP_FRAC;
        if(bird.yRender + (bird.h/2 - INSET) >= H + bottomAllowancePx) endGame(null);
      }
      accumulator -= STEP;
    }
    const leftover = over?0:accumulator;

    ctx.clearRect(0,0,W,H);
    drawBackground();
    bird.yRender = bird.y + bird.v*leftover + (over?0:0.5*G*leftover*leftover);

    drawObstaclesInterpolated(leftover);

    // Draw flame BEFORE the bird so it appears behind
    drawFlame();

    // Draw bird
    bird.draw(frameDt);

    if(started && !over) collideAndScore(leftover);

    // version (small grey)
    ctx.fillStyle='rgba(120,120,120,0.95)';
    ctx.font='700 8px Montserrat,system-ui';
    ctx.fillText('v'+VERSION, 14, H-14);

    requestAnimationFrame(loop);
  }

  // Game over / system card
  function endGame(hitStyleIdx){
    if(over) return; over=true; bird.v=0; playHit();
    finalScoreP.textContent = `Score: ${score} • Best: ${best}`;
    const box=document.getElementById('sysInfoBox'), imgEl=document.getElementById('sysImg'), tEl=document.getElementById('sysTitle'), bEl=document.getElementById('sysBlurb'), specsBox=document.getElementById('sysSpecsBox'), sEl=document.getElementById('sysSpecs'), lEl=document.getElementById('sysLinks');

    if(hitStyleIdx!=null && SYSTEMS[hitStyleIdx]){
      const info=SYSTEMS[hitStyleIdx];
      tEl.textContent=info.title||`System ${hitStyleIdx+1}`;
      bEl.textContent=info.blurb||'';
      lEl.innerHTML = info.tds && info.tds!=='#' ? `<a href="${info.tds}" target="_blank" rel="noopener" style="color:#7dcfff;text-decoration:underline">📄 Technical Data Sheet</a>` : '';
      if(info.img && info.img!=='#'){ imgEl.style.opacity='0'; imgEl.onload=()=>{ imgEl.style.opacity='1'; }; imgEl.src=info.img; imgEl.style.display='block'; } else { imgEl.style.display='none'; }
      sEl.innerHTML='';
      if(info.specTable && Array.isArray(info.specTable.headers) && Array.isArray(info.specTable.rows)){
        sEl.innerHTML='<thead><tr>'+info.specTable.headers.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specTable.rows.forEach(row=>{ const tr=document.createElement('tr'); tr.innerHTML=row.map((cell,i)=>`<td${i===0?' style="font-weight:600"':''}>${cell}</td>`).join(''); tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else if(info.specHeaders && info.specs && info.specs.length){
        sEl.innerHTML='<thead><tr>'+info.specHeaders.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specs.forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td style="font-weight:600">${k}</td><td>${v}</td>`; tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else { specsBox.style.display='none'; }
      box.style.display='block';
    } else { box.style.display='none'; imgEl.style.display='none'; }

    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop=0; requestAnimationFrame(()=>{ gameOverCard.scrollTop=0; });
    restartLocked=true; setTimeout(()=>{ restartLocked=false; },1000);
  }

  function startGame(){
    started=true; over=false; restartLocked=false;
    lastScore=score; lastEl.textContent=lastScore;
    score=0; scoreEl.textContent="0";
    obstacles.length=0; bird.reset();

    phase='VERTICALS'; bufferTime=0; challengeQueued=false; verticalsPassed=0;
    nextSpawnPx = FIRST_VERTICAL_LEAD_PIXELS; verticalsEnabled = true;

    startCard.classList.add('hidden'); gameOverCard.classList.add('hidden');
    flapBoostTimer = 0;
  }

  async function handleTap(e){
    e?.preventDefault?.(); e?.stopPropagation?.();
    await unlockAudio();
    if(!rotBlock.classList.contains('show')){
      if(!started){ startGame(); bird.flap(); return; }
      if(!over){ bird.flap(); return; }
      if(!restartLocked) startGame();
    }
  }

  // Input
  startCard.addEventListener('click', handleTap, {passive:false});
  startCard.addEventListener('touchstart', handleTap, {passive:false});
  document.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('#gameOverCard')) return;
    if (e.target.closest('#muteBtn, #fsBtn')) return;
    handleTap(e);
  }, {passive:false, capture:true});
  document.addEventListener('keydown', async (e)=>{
    if(e.code==='Space'||e.key===' '){ await handleTap(e); }
  }, {passive:false});

  // Boot
  requestAnimationFrame(loop);

  (async () => {
    try{
      const [sprite, single, bg] = await Promise.all([
        loadImageWithTimeout("assets/bird-sprite.png"),
        loadImageWithTimeout("assets/bird.png"),
        loadImageWithTimeout("assets/bg.png"),
      ]);
      birdSprite = sprite || null;
      birdFallbackImg = (!birdSprite && single) ? single : null;
      bgImg = bg || null;

      const promises=[]; for (const s of PIPE_STYLES_CFG){ promises.push(loadImageWithTimeout(s.bottom.url)); promises.push(loadImageWithTimeout(s.top.url)); }
      const results=await Promise.allSettled(promises);
      const bottoms=[], tops=[]; for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=results[i*2]?.value||null; tops[i]=results[i*2+1]?.value||null; }
      Raw.bottoms=bottoms; Raw.tops=tops; rebuildStyles();
    }catch(_){ rebuildStyles(); }
  })();
})();
</script>
</body>
</html>
