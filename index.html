<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ROCKET MO â€” Local Assets (v1.65)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; --accent:#ffd54a; --accent2:#ff7a3a; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
  }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }
  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:9; pointer-events:none; }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }

  .splash{
    pointer-events:auto; width:min(720px, 94vw);
    background:
      radial-gradient(1200px 600px at 10% 10%, rgba(255, 198, 74, .12), transparent 60%),
      radial-gradient(800px 500px at 90% 30%, rgba(255, 122, 58, .12), transparent 60%),
      rgba(20,24,28,.78);
    color:#fff; border-radius:18px; border:1px solid rgba(255,255,255,.12); backdrop-filter: blur(6px);
    box-shadow:0 22px 60px rgba(0,0,0,.55); padding:26px 22px 18px; text-align:center;
    margin-top:38px;
  }
  .logo{ display:inline-grid; place-items:center; margin-bottom:6px; }
  .logo .word{
    font-weight:800; font-size: clamp(28px, 7.2vw, 56px); letter-spacing:.5px;
    background: linear-gradient(180deg, var(--accent) 0%, #fff7c5 35%, var(--accent2) 100%);
    -webkit-background-clip: text; background-clip: text; color: transparent;
    filter: drop-shadow(0 4px 18px rgba(255, 203, 58, .35));
  }
  .cta{ margin-top:12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
  .btn{
    pointer-events:auto; cursor:pointer; user-select:none;
    padding:10px 16px; font-weight:800; border-radius:12px; font-size:14px;
    border:1px solid rgba(255,255,255,.18); color:#0b0d10; background:#ffe07a;
    box-shadow:0 6px 16px rgba(0,0,0,.25); transition: transform .06s ease, filter .06s ease;
  }
  .btn:active{ transform: translateY(1px) scale(.995); filter:brightness(.96) }
  .hint{ margin-top:8px; font-size:12px; opacity:.85 }

  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y; scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff; }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff; }
  .hidden{ display:none }

  #sysImg{ max-width:100%; max-height:240px; object-fit:contain; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px; margin:10px auto; display:none; opacity:0; transition:opacity .25s ease; }
  #sysInfoBox, #sysInfoBox * { color:#fff !important; }
  #sysBlurb { white-space:pre-line; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">ðŸ”Š Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">â›¶ Fullscreen</button>

<div class="overlay" id="overlay">
  <div id="splash" class="splash" aria-label="Title Screen" tabindex="0">
    <div class="logo"><div class="word">ROCKET MO</div></div>
    <div class="cta">
      <button id="startBtn" class="btn" title="Start">â–¶ Tap to Start</button>
      <button id="fsStartBtn" class="btn" title="Start in Fullscreen">â›¶ Fullscreen</button>
    </div>
    <div class="hint">Tap the button or press Space/Enter â€¢ Best is saved locally</div>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 â€¢ Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>
    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">â€”</span></div>
      <div id="sysBlurb" style="opacity:.95; font-size:13px; margin-bottom:8px">â€”</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. You can still start from here.</p>
  </div>
</div>

<script>
(() => {
  const VERSION = '1.65';
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  const W = 1920, H = 1080;
  const SPEED_MULT = isMobile ? 1.40 : 1.50;
  const G=4800*SPEED_MULT, LIFT_V0=-1350*SPEED_MULT, MAX_FALL=2200*SPEED_MULT, SCROLL_PPS=480*SPEED_MULT;

  const PIPE_W=180, GAP_MIN=310, GAP_MAX=450;
  const VERTICAL_X_GAP = Math.round(SCROLL_PPS * 1.8);
  const FIRST_VERTICAL_LEAD_PIXELS = VERTICAL_X_GAP;

  const CHALLENGE_BARS = 3;
  const HORIZ_SPACING_X = Math.round(W * 0.25);
  const HORIZ_MARGIN_Y  = Math.round(H * 0.18);
  const BUFFER_PIXELS   = Math.round(W * 0.06);
  const HORIZ_LEAD_PIXELS = Math.round(W * 0.08);

  const TOP_OVERLAP_FRAC=0.30, BOTTOM_OVERLAP_FRAC=0.75;

  // ðŸ”¥ Rocket plume settings â€” brighter & longer, shows on splash too
  const PIXEL_FLAME={
    gridW:64, gridH:32,
    lenFrac:1.25,          // was 1.0
    heightFrac:0.72,       // was 0.65
    offsetFrac:0.50,
    colHot:'#fffcc0',
    colMid:'#ffae4a',
    colCool:'#ff4a32',
    jitter:2,
    flicker:0.10
  };

  /* ---------- Performance knobs ---------- */
  let physicsHz = 90; let STEP = 1 / physicsHz, accumulator = 0;
  let lastTs = performance.now(); const MAX_FRAME_DT = 0.12;

  const is60HzDesktop = !isMobile; let PERF_MODE = is60HzDesktop;
  if (PERF_MODE) { physicsHz = 75; STEP = 1 / physicsHz; }

  const SMOKE = []; const SMOKE_RATE = PERF_MODE ? 22 : 40; const SMOKE_MAX = 220; let smokeTimer = 0;

  /* ---------- Canvas & layout ---------- */
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false}); ctx.imageSmoothingEnabled=true;
  function fitCSS(){ const vw=innerWidth; const vh=Math.round(window.visualViewport?visualViewport.height:innerHeight); const s=Math.min(vw/W, vh/H); canvas.style.transform=`translate(-50%, -50%) scale(${s})`; }
  addEventListener('resize', fitCSS, {passive:true}); window.visualViewport&&visualViewport.addEventListener('resize', fitCSS, {passive:true}); fitCSS();

  const rotBlock=document.getElementById('rotBlock');
  function checkOrientation(){ const landscapeOK = innerWidth >= innerHeight; rotBlock.classList.toggle('show', isMobile && !landscapeOK); }
  addEventListener('resize', checkOrientation, {passive:true}); checkOrientation();

  // Cached gradient bg (used until bg.png loads)
  let bgCache = null;
  function buildBgCache() {
    const c = document.createElement('canvas'); c.width = W; c.height = H;
    const g = c.getContext('2d');
    const g1=g.createLinearGradient(0,0,0,H);
    g1.addColorStop(0,'#0f1116'); g1.addColorStop(1,'#1a1e26');
    g.fillStyle=g1; g.fillRect(0,0,W,H);
    const r1=g.createRadialGradient(W*0.16,H*0.25,50, W*0.16,H*0.25,420);
    r1.addColorStop(0,'rgba(255,210,90,0.18)'); r1.addColorStop(1,'rgba(255,210,90,0.0)');
    g.fillStyle=r1; g.fillRect(0,0,W,H);
    const r2=g.createRadialGradient(W*0.85,H*0.35,50, W*0.85,H*0.35,520);
    r2.addColorStop(0,'rgba(255,120,60,0.14)'); r2.addColorStop(1,'rgba(255,120,60,0.0)');
    g.fillStyle=r2; g.fillRect(0,0,W,H);
    return c;
  }
  function drawBackground(){
    if(bgImg){ ctx.drawImage(bgImg,0,0,W,H); return; }
    if (!bgCache) bgCache = buildBgCache();
    ctx.drawImage(bgCache, 0, 0);
  }

  /* ---------- UI refs ---------- */
  const scoreEl=document.getElementById('scoreVal'), lastEl=document.getElementById('lastVal'), bestEl=document.getElementById('bestVal');
  const overlay=document.getElementById('overlay');
  const splash=document.getElementById('splash'), startBtn=document.getElementById('startBtn'), fsStartBtn=document.getElementById('fsStartBtn');
  const gameOverCard=document.getElementById('gameOverCard'), finalScoreP=document.getElementById('finalScoreP');
  const fsBtn=document.getElementById('fsBtn');
  function inFullscreen(){ return document.fullscreenElement||document.webkitFullscreenElement||document.msFullscreenElement; }
  function updateFsBtn(){ fsBtn.textContent = inFullscreen() ? "â¤¢ Exit" : "â›¶ Fullscreen"; }
  fsBtn.addEventListener('click', async (e)=>{ e.stopPropagation(); const el=document.documentElement; try{ if(!inFullscreen()){ await (el.requestFullscreen?.()||el.webkitRequestFullscreen?.()||el.msRequestFullscreen?.()); } else { await (document.exitFullscreen?.()||document.webkitExitFullscreen?.()||document.msExitFullscreen?.()); } }catch(_){ } updateFsBtn(); }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent=best;

  /* ---------- Audio ---------- */
  let audioCtx=null, masterGain=null, audioReady=false, muted=false;
  function createAudio(){ if(audioReady) return; const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return; audioCtx=new AC({latencyHint:"interactive"}); masterGain=audioCtx.createGain(); masterGain.gain.value=muted?0:0.85; masterGain.connect(audioCtx.destination); audioReady=true; }
  async function unlockAudio(){ try{ createAudio(); if(audioCtx && audioCtx.state!=='running'){ await audioCtx.resume(); } }catch(_){ } }
  function setMuted(m){ muted=m; if(masterGain) masterGain.gain.value=muted?0:0.85; const b=document.getElementById('muteBtn'); b.textContent=muted?"ðŸ”‡ Muted":"ðŸ”Š Sound"; b.setAttribute("aria-pressed", String(muted)); }
  document.getElementById('muteBtn').addEventListener('click', async (e)=>{ e.stopPropagation(); await unlockAudio(); setMuted(!muted); });
  function envGain(d=0.25,a=0.008,v=1){ if(!audioReady) return null; const g=audioCtx.createGain(); const t=audioCtx.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.exponentialRampToValueAtTime(0.0001,t+d); return g; }
  function woosh(d=0.22,c=1200,v=0.35){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<n;i++) data[i]=(Math.random()*2-1)*0.35; const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=c; const g=envGain(d,0.01,v); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  function crash(d=1.1){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); let b0=0,b1=0,b2=0; for(let i=0;i<n;i++){ const w=Math.random()*2-1; b0=0.997*b0+w*0.03; b1=0.985*b1+w*0.05; b2=0.95*b2+w*0.07; data[i]=(b0+b1+b2)*0.65; } const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=700; const g=envGain(d,0.02,0.45); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  const playFlap=()=>woosh(), playHit=()=>crash();

  /* ---------- Assets & styles ---------- */
  function loadImageWithTimeout(src,timeout=6000){ return new Promise((res)=>{ if(!src){ res(null); return; } const img=new Image(); img.referrerPolicy='no-referrer'; let done=false; const finish=v=>{ if(done)return; done=true; res(v||null); }; const t=setTimeout(()=>finish(null),timeout); img.onload=()=>{ clearTimeout(t); finish(img); }; img.onerror=()=>{ clearTimeout(t); finish(null); }; img.src=src; }); }
  const BIRD_SPRITE_FRAMES=4, BIRD_SPRITE_FPS=10;

  const PIPE_STYLES_CFG=[
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={bottoms:[],tops:[]}, Styles=[];
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#2e8b57"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.imageSmoothingEnabled=true; g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return {cap:ph,body:ph}; }
    const scale=drawW/(img.naturalWidth||img.width);
    const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
    const capH=Math.max(1,Math.round(capPxSrc*scale));
    const full=makeScaledCanvas(img,drawW,scaledH);
    const cap=document.createElement("canvas"), body=document.createElement("canvas");
    cap.width=drawW; cap.height=Math.min(capH,scaledH);
    body.width=drawW; body.height=Math.max(1,scaledH-cap.height);
    const cg=cap.getContext("2d"), bg=body.getContext("2d"); cg.imageSmoothingEnabled=bg.imageSmoothingEnabled=true;
    if(capFrom==="top"){ cg.drawImage(full,0,0,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,cap.height,drawW,body.height,0,0,drawW,body.height); }
    else { cg.drawImage(full,0,scaledH-cap.height,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,0,drawW,body.height,0,0,drawW,body.height); }
    return {cap,body};
  }
  function rebuildStyles(){ Styles.length=0; for(let i=0;i<PIPE_STYLES_CFG.length;i++){ const cfg=PIPE_STYLES_CFG[i]; const bot=Raw.bottoms[i], top=Raw.tops[i]; const drawW=Math.round(PIPE_W*(cfg.scale||1)); const bottom=buildCapBodyPx(bot,drawW,cfg.bottom.capPx,cfg.bottom.capFrom); const topset=buildCapBodyPx(top,drawW,cfg.top.capPx,cfg.top.capFrom); Styles.push({name:cfg.name,bottom,top:topset,drawW,botImg:bot}); } }

  /* ---------- System info for Game Over ---------- */
  const SYSTEMS = [/* (same content as v1.64 â€” omitted for brevity, keep yours intact) */];

  /* ---------- Obstacles ---------- */
  const obstacles=[]; const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function makeScaledTiled(g, tile, x, yStart, totalH, w, mode){
    const th=tile.height; if(totalH<=0||th<=0) return;
    if(mode==="topUp"){
      let y=totalH-th;
      while(y>=0){ g.drawImage(tile,x,y,w,th); y-=th; }
      const rem=totalH%th; if(rem>0) g.drawImage(tile,0,th-rem,tile.width,rem,x,0,w,rem);
    } else {
      let y=yStart, end=yStart+totalH;
      while(y+th<=end){ g.drawImage(tile,x,y,w,th); y+=th; }
      const left=end-y; if(left>0) g.drawImage(tile,0,0,tile.width,left,x,y,w,left);
    }
  }

  function makeVerticalSprite(sty, top, gap, w){
    const c=document.createElement('canvas'); c.width=w; c.height=H;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(top>0){
      const cap=sty.top.cap, body=sty.top.body;
      const capH=Math.min(cap.height,top), bodyH=top-capH;
      if(bodyH>0) makeScaledTiled(g, body, 0, 0, bodyH, w, "topUp");
      g.drawImage(cap,0,top-capH,w,capH);
    }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){
      const cap=sty.bottom.cap, body=sty.bottom.body;
      const capH=Math.min(cap.height,bottomH);
      g.drawImage(cap,0,by,w,capH);
      const remain = bottomH - capH;
      if(remain>0) makeScaledTiled(g, body, 0, by+capH, remain, w, "bottomDown");
    }
    return c;
  }
  function makeHorizontalSprite(sty){
    const img=sty.botImg, drawW=sty.drawW;
    const c=document.createElement('canvas'); const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(img){
      const scale=drawW/(img.naturalWidth||img.width);
      const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
      c.width=scaledH; c.height=drawW;
      g.translate(0,drawW); g.rotate(-Math.PI/2);
      g.drawImage(img, 0, 0, img.naturalWidth||img.width, img.naturalHeight||img.height, 0, 0, drawW, scaledH);
    }else{
      c.width=drawW; c.height=drawW; g.fillStyle="#2e8b57"; g.fillRect(0,0,c.width,c.height);
    }
    return c;
  }

  function spawnVerticalAt(xPos){
    if(!Styles.length) return;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin, minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin); if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap); if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    const idx=Math.floor(Math.random()*Styles.length), sty=Styles[idx], w=sty.drawW;
    obstacles.push({type:'V', x:xPos, top, gap, w, styleIndex:idx, scored:false, sprite:makeVerticalSprite(sty,top,gap,w)});
  }
  const spawnVertical=()=>spawnVerticalAt(W);

  function spawnHorizontalAt(xStart){
    if(!Styles.length) return;
    const idx=Math.floor(Math.random()*Styles.length), sty=Styles[idx];
    const sprite=makeHorizontalSprite(sty);
    const w=sprite.width, h=sty.drawW, y=randInt(HORIZ_MARGIN_Y,H-HORIZ_MARGIN_Y-h);
    obstacles.push({type:'H', x:xStart, y, w, h, styleIndex:idx, scored:false, sprite});
  }
  function spawnHorizontalChallenge(){
    const firstX=W+HORIZ_LEAD_PIXELS;
    let lastRight=0;
    for(let i=0;i<CHALLENGE_BARS;i++){
      const x=(i===0?firstX:lastRight+HORIZ_SPACING_X);
      spawnHorizontalAt(x);
      const last=obstacles[obstacles.length-1];
      lastRight=last.x+last.w;
    }
  }

  // Phases for mixing vertical sections and horizontal challenges
  let phase='VERTICALS', bufferTime=0, challengeQueued=false, verticalsPassed=0, nextSpawnPx=FIRST_VERTICAL_LEAD_PIXELS, verticalsEnabled=true;

  function stepObstacles(dt){
    if(!started || over) return;
    for(const o of obstacles){ o.x -= SCROLL_PPS*dt; }
    for(let i=obstacles.length-1;i>=0;i--) if(obstacles[i].x + obstacles[i].w <= 0) obstacles.splice(i,1);

    if(phase==='VERTICALS'){
      if(verticalsEnabled){
        nextSpawnPx -= SCROLL_PPS*dt;
        while(nextSpawnPx<=0){ spawnVertical(); nextSpawnPx += VERTICAL_X_GAP; }
      }
      if(challengeQueued){
        phase='PRE_BUFFER'; verticalsEnabled=false;
        nextSpawnPx = VERTICAL_X_GAP;
        bufferTime = BUFFER_PIXELS / SCROLL_PPS;
        challengeQueued=false;
      }
      return;
    }
    if(phase==='PRE_BUFFER'){ bufferTime-=dt; if(bufferTime<=0){ phase='H_CHALLENGE'; spawnHorizontalChallenge(); } return; }
    if(phase==='H_CHALLENGE'){ if(obstacles.findIndex(o=>o.type==='H')===-1){ phase='POST_BUFFER'; bufferTime=BUFFER_PIXELS/SCROLL_PPS; } return; }
    if(phase==='POST_BUFFER'){ bufferTime-=dt; if(bufferTime<=0){ phase='VERTICALS'; verticalsEnabled=true; } return; }
  }

  function scoreUp(){ score++; scoreEl.textContent=score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); } }

  function collideAndScore(leftover){
    const BIRD_INSET=8, GAP_FORGIVE=12;
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.type==='V'){
        const overlapX=(bx2>xR)&&(bx1<xR+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){ endGame(o.styleIndex); return true; }
        }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); verticalsPassed++; if(verticalsPassed>0 && verticalsPassed%10===0){ if(phase==='VERTICALS') challengeQueued=true; } }
      } else {
        const overlapX=(bx2>xR)&&(bx1<xR+o.w), overlapY=(by2>o.y)&&(by1<o.y+o.h);
        if(overlapX && overlapY){ endGame(o.styleIndex); return true; }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); }
      }
    }
    return false;
  }

  function drawObstaclesInterpolated(leftover){
    const viewLeft = -W * 0.15, viewRight = W * 1.15;
    for(const o of obstacles){
      const xR= o.x - (started && !over ? SCROLL_PPS*leftover : 0);
      if (xR + o.w < viewLeft || xR > viewRight) continue;
      if(o.sprite) ctx.drawImage(o.sprite, xR, (o.type==='H'?o.y:0), o.w, (o.type==='H'?o.h:H));
    }
  }

  /* ---------- Bird, flame, smoke ---------- */
  let birdSprite=null, birdFallbackImg=null, bgImg=null;

  const bird={ x:Math.round(W*0.167), y:Math.round(H*0.5), w:Math.round(H*0.069), h:Math.round(H*0.069), v:0, yRender:0, animTime:0, angle:0,
    computeAngle(){ this.angle=Math.max(-0.45, Math.min(0.9, (this.v/600)*0.5)); return this.angle; },
    draw(dt){
      const ang=this.computeAngle(); this.animTime+=dt;
      ctx.save(); ctx.translate(this.x+this.w/2, this.yRender); ctx.rotate(ang);
      if(birdSprite&&birdSprite.complete&&birdSprite.naturalWidth){
        const frames=BIRD_SPRITE_FRAMES,fps=BIRD_SPRITE_FPS;
        const frameW=Math.floor(birdSprite.naturalWidth/frames), frameH=birdSprite.naturalHeight;
        const idx=Math.floor(this.animTime*fps)%frames, sx=idx*frameW;
        ctx.drawImage(birdSprite,sx,0,frameW,frameH,-this.w/2,-this.h/2,this.w,this.h);
      } else if(birdFallbackImg&&birdFallbackImg.complete&&birdFallbackImg.naturalWidth){
        ctx.drawImage(birdFallbackImg,-this.w/2,-this.h/2,this.w,this.h);
      } else { ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h); }
      ctx.restore();
    },
    step(dt){ if(!started||over) return; this.v+=G*dt; if(this.v>MAX_FALL) this.v=MAX_FALL; this.y+=this.v*dt; },
    flap(){ if(!started||over) return; this.v=LIFT_V0; woosh(); },
    reset(){ this.y=Math.round(H*0.5); this.v=0; this.animTime=0; this.angle=0; }
  };

  // flame buffer (pixel-art style but with additive glow)
  const flameCanvas=document.createElement('canvas'); flameCanvas.width=PIXEL_FLAME.gridW; flameCanvas.height=PIXEL_FLAME.gridH;
  const flameCtx=flameCanvas.getContext('2d',{alpha:true}); flameCtx.imageSmoothingEnabled=false;

  function drawPixelFlame(){
    if(over) return; // hide only on Game Over; shows on splash & gameplay

    const ang=bird.computeAngle(), fwdX=Math.cos(ang), fwdY=Math.sin(ang);
    const centerX=bird.x+bird.w/2, centerY=bird.yRender;
    const nozzleX=centerX - fwdX*(bird.w*PIXEL_FLAME.offsetFrac);
    const nozzleY=centerY - fwdY*(bird.w*PIXEL_FLAME.offsetFrac);

    // build pixel flame texture
    flameCtx.clearRect(0,0,flameCanvas.width,flameCanvas.height);
    const gw=flameCanvas.width, gh=flameCanvas.height, cy=Math.floor(gh/2);
    for(let x=0;x<gw;x++){
      const t=x/(gw-1);
      const half=Math.max(1, Math.floor((0.2+0.85*t)*(gh*0.48))); // a touch taller
      const jag=(Math.random()*2-1)*PIXEL_FLAME.jitter;
      const hh=Math.max(1, Math.min(gh-1, half+jag));
      for(let y=-hh;y<=hh;y++){
        let col; const ay=Math.abs(y);
        if(ay<=hh*0.33) col=PIXEL_FLAME.colHot;
        else if(ay<=hh*0.72) col=PIXEL_FLAME.colMid;
        else col=PIXEL_FLAME.colCool;
        if(Math.random()<0.08 && ay>hh*0.6) continue;
        flameCtx.fillStyle=col; flameCtx.fillRect(x, cy+y, 1, 1);
      }
    }

    // draw with additive blend + slight base bloom
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.translate(nozzleX, nozzleY);
    ctx.rotate(ang);
    const drawW=bird.w*(PIXEL_FLAME.lenFrac*(1+(Math.random()*2-1)*PIXEL_FLAME.flicker));
    const drawH=bird.h*PIXEL_FLAME.heightFrac;
    ctx.translate(0, -drawH/2);
    ctx.drawImage(flameCanvas, -flameCanvas.width, 0, flameCanvas.width, flameCanvas.height, 0, 0, drawW, drawH);

    // tiny core glow at the nozzle
    const coreR = Math.max(4, Math.floor(bird.w*0.10));
    ctx.fillStyle='rgba(255,240,160,0.85)';
    ctx.beginPath(); ctx.ellipse(-2, drawH/2, coreR, coreR*0.6, 0, 0, Math.PI*2); ctx.fill();

    ctx.restore();
    ctx.globalCompositeOperation='source-over';
  }

  function updateSmoke(frameDt){
    smokeTimer += frameDt * SMOKE_RATE;
    if (SMOKE.length > SMOKE_MAX) return;
    while (smokeTimer >= 1) {
      smokeTimer--;
      if (!over) {
        const ang = bird.computeAngle(), fwdX=Math.cos(ang), fwdY=Math.sin(ang);
        const nozzleX = bird.x + bird.w/2 - fwdX * (bird.w * PIXEL_FLAME.offsetFrac);
        const nozzleY = bird.yRender       - fwdY * (bird.w * PIXEL_FLAME.offsetFrac);
        SMOKE.push({ x:nozzleX, y:nozzleY, size:Math.floor(6+Math.random()*6), vX:-fwdX*(80+Math.random()*40), vY:-fwdY*(80+Math.random()*40)+(Math.random()*30-15), life:0.7+Math.random()*0.4, age:0, shade:180+Math.floor(Math.random()*50) });
      }
    }
  }
  function drawSmoke(frameDt){
    for(let i=SMOKE.length-1;i>=0;i--){
      const p=SMOKE[i]; p.age+=frameDt; if(p.age>p.life){ SMOKE.splice(i,1); continue; }
      const t=p.age/p.life; p.x+=p.vX*frameDt; p.y+=p.vY*frameDt; p.vY-=8*frameDt;
      const alpha=(1-t)*0.35, s=Math.max(4,Math.floor(p.size*(1+t*1.2)));
      ctx.fillStyle=`rgba(${p.shade},${p.shade},${p.shade},${alpha})`;
      ctx.fillRect(Math.round(p.x - s/2), Math.round(p.y - s/2), s, s);
    }
  }

  /* ---------- Game flow ---------- */
  async function startGame(){
    if(started) return;
    unlockAudio().catch(()=>{});
    started=true; over=false; restartLocked=false;
    lastScore=score; lastEl.textContent=lastScore;
    score=0; scoreEl.textContent="0";
    obstacles.length=0; bird.reset();

    for(let i=0;i<12;i++){ SMOKE.push({ x:bird.x+bird.w*0.35, y:bird.y, size:6+Math.random()*6, vX:-40+Math.random()*-40, vY:(Math.random()*40-20), life:0.5+Math.random()*0.5, age:0, shade:180+Math.floor(Math.random()*50) }); }

    phase='VERTICALS'; bufferTime=0; challengeQueued=false; verticalsPassed=0;
    nextSpawnPx = FIRST_VERTICAL_LEAD_PIXELS; verticalsEnabled=true;

    splash.classList.add('hidden');
    gameOverCard.classList.add('hidden');

    bird.flap();
  }

  function endGame(hitStyleIdx){
    if(over) return; over=true; bird.v=0; crash();
    finalScoreP.textContent=`Score: ${score} â€¢ Best: ${best}`;

    const box   = document.getElementById('sysInfoBox');
    const imgEl = document.getElementById('sysImg');
    const tEl   = document.getElementById('sysTitle');
    const bEl   = document.getElementById('sysBlurb');
    const specsBox = document.getElementById('sysSpecsBox');
    const sEl   = document.getElementById('sysSpecs');
    const lEl   = document.getElementById('sysLinks');

    // (fill game-over info exactly like your previous working version)
    box.style.display='none'; imgEl.style.display='none'; // keep if you donâ€™t want system info now
    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop=0; requestAnimationFrame(()=>{ gameOverCard.scrollTop=0; });
    restartLocked = true; setTimeout(()=>{ restartLocked=false; }, 1000);
  }

  /* ---------- Input ---------- */
  startBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); startGame(); }, {passive:false});
  fsStartBtn.addEventListener('click', async (e)=>{
    e.preventDefault(); e.stopPropagation();
    try{ const el=document.documentElement; if(!document.fullscreenElement){ await (el.requestFullscreen?.()||el.webkitRequestFullscreen?.()||el.msRequestFullscreen?.()); } }catch(_){}
    startGame();
  }, {passive:false});
  splash.addEventListener('pointerdown', (e)=>{ if(e.target.closest('#startBtn,#fsStartBtn')) return; e.preventDefault(); startGame(); }, {passive:false});
  document.addEventListener('pointerdown', (e)=>{
    if(e.target.closest('#muteBtn, #fsBtn, #gameOverCard')) return;
    if(!started){ return; }
    e.preventDefault(); e.stopPropagation();
    if(!over){ bird.flap(); } else if(!restartLocked){ startGame(); }
  }, {passive:false, capture:true});
  document.getElementById('overlay').addEventListener('pointerdown', (e)=>{
    if(!over) return; if(e.target.closest('#gameOverCard')) return; e.preventDefault(); if(!restartLocked) startGame();
  }, {passive:false});
  document.addEventListener('keydown', (e)=>{
    const splashVisible = !splash.classList.contains('hidden');
    const goVisible = !gameOverCard.classList.contains('hidden');
    if((splashVisible) && (e.code==='Space' || e.key===' ' || e.key==='Enter')){ e.preventDefault(); startGame(); return; }
    if(goVisible && (e.code==='Space' || e.key==='Enter')){ e.preventDefault(); if(!restartLocked) startGame(); return; }
    if(started && !over && (e.code==='Space' || e.key===' ')){ e.preventDefault(); bird.flap(); }
  });

  /* ---------- Main loop ---------- */
  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT) frameDt=MAX_FRAME_DT; if(frameDt<0) frameDt=0; lastTs=ts;

    accumulator+=frameDt;
    while(accumulator>=STEP){
      stepObstacles(STEP);
      bird.step(STEP);

      const topWrap   = -bird.h * TOP_OVERLAP_FRAC;
      const bottomWrap=  H + bird.h * BOTTOM_OVERLAP_FRAC;
      if (started && !over){
        if (bird.y < topWrap){ const overshoot = topWrap - bird.y; bird.y = bottomWrap - overshoot; }
        else if (bird.y > bottomWrap){ const overshoot = bird.y - bottomWrap; bird.y = topWrap + overshoot; }
      }
      accumulator-=STEP;
    }
    const leftover=over?0:accumulator;

    ctx.clearRect(0,0,W,H);
    drawBackground();

    bird.yRender = bird.y + bird.v*leftover + (over?0:0.5*G*leftover*leftover);

    updateSmoke(frameDt);
    drawSmoke(frameDt);
    drawObstaclesInterpolated(leftover);

    // ðŸ”¥ draw flame before the bird so it appears behind the sprite but visible
    drawPixelFlame();
    bird.draw(frameDt);

    if(started && !over) collideAndScore(leftover);

    if(started || over){ ctx.fillStyle='rgba(120,120,120,0.95)'; ctx.font='700 8px Montserrat,system-ui'; ctx.fillText('v'+VERSION, 14, H-14); }

    requestAnimationFrame(loop);
  }

  /* ---------- Boot ---------- */
  requestAnimationFrame(loop);

  // Assets
  let birdSpriteRef=null, birdFallbackRef=null, bgImg=null;
  (async () => {
    try{
      const [sprite, single, bg] = await Promise.all([
        loadImageWithTimeout("assets/bird-sprite.png"),
        loadImageWithTimeout("assets/bird.png"),
        loadImageWithTimeout("assets/bg.png"),
      ]);
      birdSprite = sprite || null;
      birdFallbackImg = (!birdSprite && single) ? single : null;
      bgImg = bg || null;

      const promises=[]; for(const s of PIPE_STYLES_CFG){ promises.push(loadImageWithTimeout(s.bottom.url)); promises.push(loadImageWithTimeout(s.top.url)); }
      const results=await Promise.allSettled(promises);
      const bottoms=[], tops=[];
      for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=results[i*2]?.value||null; tops[i]=results[i*2+1]?.value||null; }
      Raw.bottoms=bottoms; Raw.tops=tops; rebuildStyles();
    }catch(_){ rebuildStyles(); }
  })();
})();
</script>
</body>
</html>
