<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flappy Mo â€” Local Assets (v1.46-snd06)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    box-shadow:0 10px 30px rgba(0,0,0,.5);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
    scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff; }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff; }
  .hidden{ display:none }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:999 }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  #loadingOverlay{
    position:fixed; inset:0; display:grid; place-items:center;
    background:#0b0d10; color:#fff; z-index:2000;
    font-weight:800; font-size:18px;
  }

  #sysImg { max-width:100%; max-height:240px; object-fit:contain; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px; margin:10px 0; display:none; opacity:0; transition:opacity .25s ease; }
  #sysInfoBox, #sysInfoBox * { color:#fff !important; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">ðŸ”Š Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">â›¶ Fullscreen</button>

<!-- Overlays -->
<div class="overlay">
  <div id="startCard" class="card">
    <h1>Tap to Start</h1>
    <p>Tap again to flap â€¢ Best is saved</p>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 â€¢ Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>

    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">â€”</span></div>
      <div id="sysBlurb" style="opacity:.9; font-size:13px; margin-bottom:8px; white-space:pre-line">â€”</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<!-- Rotate blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. Turn your device to play.</p>
  </div>
</div>

<div id="loadingOverlay">Loadingâ€¦</div>

<script>
(() => {
  const VERSION = '1.46-snd06';
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  // WORLD
  const W = 1920, H = 1080;

  // Physics
  const SPEED_MULT = isMobile ? 1.40 : 1.50;
  const G         = 4800 * SPEED_MULT;
  const LIFT_V0   = -1350 * SPEED_MULT;
  const MAX_FALL  = 2200 * SPEED_MULT;
  const SCROLL_PPS=  480 * SPEED_MULT;

  // Pipes
  const PIPE_W    = 180;
  const GAP_MIN   = 310, GAP_MAX = 450;
  const PIPE_SPAWN_EVERY_S = 1.8;

  const BIRD_INSET = 8, GAP_FORGIVE = 12;

  /* ---------- PHASE ENGINE ----------
     VERTICALS  -> (after each 10 passed verticals) PRE/POST BUFFER around horizontals
     PRE_BUFFER -> H_CHALLENGE (spawn 3 horizontals)
     H_CHALLENGE-> POST_BUFFER
     POST_BUFFER-> VERTICALS (repeat)
     No mixing of types.
  -----------------------------------*/
  let phase = 'VERTICALS';
  let spawnTimer = 0;

  // Challenge config
  const CHALLENGE_BARS = 3;
  const HORIZ_SPACING_X = Math.round(W * 0.25); // spacing between the 3 bars
  const HORIZ_MARGIN_Y  = Math.round(H * 0.18); // keep bars away from top/bottom

  // Your pref: single buffer both before & after (6% width)
  const BUFFER_PIXELS = Math.round(W * 0.06);
  const HORIZ_LEAD_PIXELS = Math.round(W * 0.08); // start first bar a bit off-screen for nicer entrance

  let bufferTime = 0;           // seconds remaining in current buffer
  let postBuffer = false;       // whether we're doing the "after" buffer
  let challengeQueued = false;  // request to start a challenge after buffer
  let verticalsPassed = 0;      // how many verticals were scored

  // Canvas fit
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = true;
  function fit(){ const vw=innerWidth, vh=Math.round(visualViewport?visualViewport.height:innerHeight); const s=Math.min(vw/W, vh/H); canvas.style.transform=`translate(-50%, -50%) scale(${s})`; }
  addEventListener('resize', fit, {passive:true}); visualViewport&&visualViewport.addEventListener('resize', fit, {passive:true}); fit();

  // Orientation
  const rotBlock = document.getElementById('rotBlock');
  function checkOrientation(){ rotBlock.classList.toggle('show', innerWidth<innerHeight); }
  addEventListener('resize', checkOrientation, {passive:true}); checkOrientation();

  // UI
  const scoreEl = document.getElementById('scoreVal');
  const lastEl  = document.getElementById('lastVal');
  const bestEl  = document.getElementById('bestVal');
  const startCard   = document.getElementById('startCard');
  const gameOverCard= document.getElementById('gameOverCard');
  const finalScoreP = document.getElementById('finalScoreP');
  const fsBtn = document.getElementById('fsBtn');

  function inFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
  function updateFsBtn(){ const full=!!inFullscreen(); fsBtn.textContent = full ? "â¤¢ Exit" : "â›¶ Fullscreen"; }
  fsBtn.addEventListener('click', async (e)=>{ e.stopPropagation(); const el=document.documentElement; try{ if(!inFullscreen()){ await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.msRequestFullscreen?.() ); } else { await (document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.msExitFullscreen?.()); } }catch(_){} updateFsBtn(); }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  // Scores
  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent = best;

  // ---------- AUDIO (robust unlock) ----------
  let audioCtx=null, masterGain=null, audioReady=false, muted=false;

  function createAudio(){
    if(audioReady) return;
    const Ctor = window.AudioContext || window.webkitAudioContext;
    if(!Ctor) return;
    audioCtx = new Ctor({ latencyHint: "interactive" });
    masterGain = audioCtx.createGain();
    masterGain.gain.value = muted ? 0 : 0.85;
    masterGain.connect(audioCtx.destination);
    audioReady = true;
  }

  async function unlockAudio(){
    try{
      createAudio();
      if(audioCtx && audioCtx.state !== 'running'){
        await audioCtx.resume();
      }
    }catch(_){}
  }

  function setMuted(m){
    muted = m;
    if(masterGain) masterGain.gain.value = muted ? 0 : 0.85;
    const b=document.getElementById('muteBtn');
    b.textContent = muted ? "ðŸ”‡ Muted" : "ðŸ”Š Sound";
    b.setAttribute("aria-pressed", String(muted));
  }

  document.getElementById('muteBtn').addEventListener('click', async (e)=>{
    e.stopPropagation();
    await unlockAudio();
    setMuted(!muted);
  });

  // Simple SFX
  function envGain(duration=0.25, attack=0.008, volume=1){
    const g = audioCtx.createGain();
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(volume, now + attack);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    return g;
  }
  function noiseWoosh(dur=0.22, cutoff=1200, vol=0.35){
    if(!audioReady || muted) return;
    const n = Math.max(1, audioCtx.sampleRate * dur);
    const buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0;i<n;i++) data[i] = (Math.random()*2 - 1) * 0.35;
    const src = audioCtx.createBufferSource(); src.buffer = buf;
    const lp = audioCtx.createBiquadFilter(); lp.type = "lowpass"; lp.frequency.value = cutoff;
    const g  = envGain(dur, 0.01, vol);
    src.connect(lp); lp.connect(g); g.connect(masterGain);
    src.start(); src.stop(audioCtx.currentTime + dur + 0.05);
  }
  function hitWave(dur=1.1){
    if(!audioReady || muted) return;
    const n = Math.max(1, audioCtx.sampleRate * dur);
    const buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    let b0=0,b1=0,b2=0;
    for(let i=0;i<n;i++){
      const white = Math.random()*2-1;
      b0 = 0.997*b0 + white*0.03;
      b1 = 0.985*b1 + white*0.05;
      b2 = 0.95*b2  + white*0.07;
      data[i] = (b0+b1+b2)*0.65;
    }
    const src = audioCtx.createBufferSource(); src.buffer = buf;
    const lp = audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value = 700;
    const g  = envGain(dur, 0.02, 0.45);
    src.connect(lp); lp.connect(g); g.connect(masterGain);
    src.start(); src.stop(audioCtx.currentTime + dur + 0.05);
  }
  function blip(vol=0.2, freq=880, dur=0.06){
    if(!audioReady || muted) return;
    const o = audioCtx.createOscillator(); o.type='square'; o.frequency.value=freq;
    const g = envGain(dur, 0.003, vol);
    o.connect(g); g.connect(masterGain);
    o.start(); o.stop(audioCtx.currentTime + dur + 0.02);
  }

  const playFlap = ()=> noiseWoosh(0.22, 1200, 0.35);
  const playHit  = ()=> hitWave(1.1);
  const playScore= ()=> blip(0.18, 1046, 0.055); // small positive click

  // Try to unlock on visibility change (iOS sometimes needs this)
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') unlockAudio(); }, {passive:true});

  // Asset helpers
  function loadImageWithTimeout(src, timeoutMs=6000){
    return new Promise((resolve) => {
      if(!src){ resolve(null); return; }
      const img = new Image(); img.referrerPolicy='no-referrer';
      let done=false; const finish=(v)=>{ if(done) return; done=true; resolve(v||null); };
      const timer=setTimeout(()=>finish(null), timeoutMs);
      img.onload=()=>{ clearTimeout(timer); finish(img); };
      img.onerror=()=>{ clearTimeout(timer); finish(null); };
      img.src=src;
    });
  }
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#3a3a3a"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return { cap:ph, body:ph }; }
    const scale = drawW / (img.naturalWidth || img.width);
    const scaledH = Math.max(1, Math.round((img.naturalHeight || img.height) * scale));
    const capH    = Math.max(1, Math.round(capPxSrc * scale));
    const full = makeScaledCanvas(img, drawW, scaledH);
    const cap  = document.createElement("canvas");
    const body = document.createElement("canvas");
    cap.width = drawW; cap.height = Math.min(capH, scaledH);
    body.width = drawW; body.height = Math.max(1, scaledH - cap.height);
    const cg = cap.getContext("2d"), bg = body.getContext("2d");
    cg.imageSmoothingEnabled = bg.imageSmoothingEnabled = true;
    if (capFrom === "top") {
      cg.drawImage(full, 0, 0, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, cap.height, drawW, body.height, 0, 0, drawW, body.height);
    } else {
      cg.drawImage(full, 0, scaledH - cap.height, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, 0, drawW, body.height, 0, 0, drawW, body.height);
    }
    return { cap, body };
  }

  // Styles
  const PIPE_STYLES_CFG = [
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] };
  const Styles=[];
  function rebuildStyles(){
    Styles.length=0;
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      const cfg=PIPE_STYLES_CFG[i];
      const bot=Raw.bottoms[i], top=Raw.tops[i];
      const drawW = Math.round(PIPE_W * (cfg.scale || 1));
      const bottom = buildCapBodyPx(bot, drawW, cfg.bottom.capPx, cfg.bottom.capFrom);
      const topset = buildCapBodyPx(top, drawW, cfg.top.capPx,   cfg.top.capFrom);
      Styles.push({ name:cfg.name, bottom, top:topset, drawW, botImg: bot });
    }
  }

  /* Systems (abbrev; same as your good version) */
  const SYSTEMS = [
    { title:"EATNASTAK (DOUBLE FACE)", blurb:`When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system
offers unmatched flexibility, allowing you to reconfigure it as often as needed to suit your evolving preferences. Whether expanding
your collection or rearranging your space, Aetnastak provides the adaptability and reliability you need for efficient and organized
library management.`, img:"assets/pipe1.png", tds:"#",
      specHeaders:["Specification","Standard Dimensions"],
      specs:[["Width","24, 30, 36\""],["Depth","7â€“16\""],["Height","30â€“108\""],["Shelf Load Capacity","Up to 50 psf"]]},
    { title:"SMARTSHELF (FIXED, FULL DEPTH)", blurb:"Montel's patented SmartShelf is the most versatile storage shelving system available today. This innovative 4-post shelving offers complete flexibility, accommodating items of all shapes and sizes. It is also designed for easy assembly and reconfiguration.", img:"assets/pipe2.png", tds:"#",
      specHeaders:["Specification","Standard Dimensions"],
      specs:[["Width","24â€“54\" incl. 1M"],["Depth","12â€“36\""],["Height","30â€“120\""],["Frame Load Capacity","Up to 2,500 lbs"],["Shelf Load Capacity","Up to 500 lbs"]]},
    { title:"4D Wide Span", blurb:"Montelâ€™s 4D Wide Span semi-industrial racking offers the ultimate solution for storing large, heavy items with ease. Engineered for strength and versatility, its robust beams support direct item placement, while optional drop panels transform the structure into sturdy shelving. For enhanced functionality, 4D frames seamlessly integrate with SmartShelf 4-Post accessories, delivering unmatched adaptability to meet your storage needs.", img:"assets/pipe3.png", tds:"#",
      specHeaders:["Specification","Capacity"],
      specs:[["Load per Bay","Up to 5,000 lbs"],["Load per Level","3\" Beam 1,000 lbs /pair"],["Span","4\" Beam 1,500 lbs /pair"],["Height","4'â€“8'"],["Depth","Up to 20'"]]},
    { title:"SmartSpace", blurb:"Montelâ€™s SmartSpace storage system offers a cost-effective and versatile solution for organizing light objects. Designed with efficiency in mind, the SmartSpace system ensures quick and hassle-free installation, helping you save time and reduce expenses. Choose between two tailored options, manual or mechanically assisted, to meet your unique storage requirements with ease and precision.", img:"assets/pipe4.png", tds:"#",
      specHeaders:["Specification","Capacity"],
      specs:[["Section Load Capacity","2,000 lbs"],["Section Length","24\"â€“48\""],["Section Depth","Panels 12\"â€“48\"; Columns 18\"â€“48\""],["Carriage Load Capacity","16,000 lbs"],["Carriage Length","Max 24'"]]},
    { title:"SmartGlide", blurb:`Montelâ€™s SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system...`, img:"assets/pipe5.png", tds:"#",
      specHeaders:null, specs:[]},
    { title:"GREENRAK", blurb:"Montelâ€™s GREENRAKÂ® 2.0 mobile system has been developed specifically for growing applications...", img:"assets/greenrak.png", tds:"#",
      specTable:{headers:["Specification","Section","Mobile"], rows:[["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],["Depth","â€”","36â€, 42â€, 48â€"],["Length","4â€™, 8â€™","Max 50â€™"]]}},
    { title:"Mobilex", blurb:"Montel's Mobilex mechanical-assist mobile storage systems provide...", img:"assets/pipe7.png", tds:"#",
      specHeaders:["Specification","Capacity"], specs:[["Load Capacity","1,000 lbs/lf"],["Depth","3'â€“45'"],["Length","15\"â€“48\""]]},
    { title:"SAFERAK 32P & 60P", blurb:"Unlock the full potential of your storage with Montelâ€™s cutting-edge powered mobile racking system...", img:"assets/pipe8.png", tds:"#",
      specTable:{headers:["Specification","SAFERAK 32P","SAFERAK 60P"], rows:[["Load per Double-Bay","32,000lbs","60,000lbs"],["Load per Carriage","256,000 lbs","480,000 lbs"],["Bay Depth","Up to 8'","Up to 8'"],["Bay Width","Up to 12'","Up to 12'"],["Carriage Length","Up to 100â€™","Up to 120â€™"],["Industrial Safeties","YES","YES"]]}}
  ];

  /* Obstacles */
  const obstacles=[];
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function buildVerticalSprite(sty, top, gap, w){
    const c=document.createElement('canvas'); c.width=w; c.height=H;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(top>0){
      const cap=sty.top.cap, body=sty.top.body;
      const capH=Math.min(cap.height,top), bodyH=top-capH;
      if(bodyH>0){
        let y=top-capH-body.height;
        while(y>=0){ g.drawImage(body,0,y,w,body.height); y-=body.height; }
        const rem=(top-capH)%body.height;
        if(rem>0) g.drawImage(body,0,body.height-rem,body.width,rem,0,0,w,rem);
      }
      g.drawImage(cap,0,top-capH,w,capH);
    }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){
      const cap=sty.bottom.cap, body=sty.bottom.body;
      const capH=Math.min(cap.height,bottomH);
      g.drawImage(cap,0,by,w,capH);
      let y=by+capH, filled=0, remain=bottomH-capH;
      while(filled+body.height<=remain){ g.drawImage(body,0,y,w,body.height); y+=body.height; filled+=body.height; }
      const left=remain-filled;
      if(left>0) g.drawImage(body,0,0,body.width,left,0,y,w,left);
    }
    return c;
  }

  function buildHorizontalSprite(sty){
    const img=sty.botImg; if(!img) return null;
    const drawW=sty.drawW, scale=drawW/(img.naturalWidth||img.width);
    const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale)); // length
    const c=document.createElement('canvas'); c.width=scaledH; c.height=drawW;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    g.translate(0,drawW); g.rotate(-Math.PI/2); // face left
    g.drawImage(img,0,0,img.naturalWidth||img.width,img.naturalHeight||img.height,0,0,drawW,scaledH);
    return c;
  }

  function spawnVertical(){
    if(!Styles.length) return;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin, minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin); if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap); if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex], w=sty.drawW;
    const sprite=buildVerticalSprite(sty,top,gap,w);
    obstacles.push({type:'V',x:W,top,gap,w,styleIndex,scored:false,sprite});
  }

  function spawnHorizontalAt(xStart){
    if(!Styles.length) return;
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex];
    const sprite=buildHorizontalSprite(sty); if(!sprite) return;
    const w=sprite.width, h=sty.drawW, y=randInt(HORIZ_MARGIN_Y,H-HORIZ_MARGIN_Y-h);
    obstacles.push({type:'H',x:xStart,y,w,h,styleIndex,scored:false,sprite});
  }

  function spawnHorizontalChallenge(){
    const firstX = W + HORIZ_LEAD_PIXELS; // push first bar further off-screen
    let lastRight=0;
    for(let i=0;i<CHALLENGE_BARS;i++){
      const x=(i===0?firstX:lastRight+HORIZ_SPACING_X);
      spawnHorizontalAt(x);
      const last=obstacles[obstacles.length-1];
      lastRight = last.x + last.w;
    }
  }

  function stepObstacles(dt){
    // Move & cleanup
    for(const o of obstacles){ o.x -= SCROLL_PPS*dt; }
    for(let i=obstacles.length-1;i>=0;i--) if(obstacles[i].x+obstacles[i].w<=0) obstacles.splice(i,1);

    // Phase logic
    if(phase==='VERTICALS'){
      spawnTimer += dt * SPEED_MULT;
      while(spawnTimer >= PIPE_SPAWN_EVERY_S){ spawnVertical(); spawnTimer -= PIPE_SPAWN_EVERY_S; }
      if(challengeQueued){
        phase='PRE_BUFFER';
        bufferTime = BUFFER_PIXELS / SCROLL_PPS; // 6% pre-gap
        postBuffer = false;
        challengeQueued=false;
      }
      return;
    }

    if(phase==='PRE_BUFFER'){
      bufferTime -= dt;
      if(bufferTime<=0){
        phase='H_CHALLENGE';
        spawnHorizontalChallenge();
      }
      return;
    }

    if(phase==='H_CHALLENGE'){
      // wait until all horizontals are gone
      if(obstacles.findIndex(o=>o.type==='H')===-1){
        phase='POST_BUFFER';
        bufferTime = BUFFER_PIXELS / SCROLL_PPS; // 6% post-gap
        postBuffer = true;
      }
      return;
    }

    if(phase==='POST_BUFFER'){
      bufferTime -= dt;
      if(bufferTime<=0){
        phase='VERTICALS';
        spawnTimer=0; // reset cadence
        postBuffer = false;
      }
      return;
    }
  }

  function scoreUp(){ score++; scoreEl.textContent=score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); } playScore(); }

  function collideAndScore(leftover){
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.type==='V'){
        const overlapX=(bx2>xR)&&(bx1<xR+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){ endGame(o.styleIndex); return true; }
        }
        if(!o.scored && (xR+o.w)<bx1){
          o.scored=true; scoreUp();
          verticalsPassed++;
          if(verticalsPassed>0 && verticalsPassed%10===0){
            if(phase==='VERTICALS') challengeQueued=true;
          }
        }
      } else {
        const overlapX=(bx2>xR)&&(bx1<xR+o.w), overlapY=(by2>o.y)&&(by1<o.y+o.h);
        if(overlapX && overlapY){ endGame(o.styleIndex); return true; }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); }
      }
    }
    return false;
  }

  function drawObstaclesInterpolated(leftover){
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.sprite) ctx.drawImage(o.sprite, xR, (o.type==='H'?o.y:0), o.w, (o.type==='H'?o.h:H));
    }
  }

  // Background & bird
  let bgImg=null, birdImg=null;
  function drawBackground(){ if(bgImg) ctx.drawImage(bgImg,0,0,W,H); else { ctx.fillStyle="#d9f4ff"; ctx.fillRect(0,0,W,H); } }

  const bird={
    x:Math.round(W*0.167), y:Math.round(H*0.5),
    w:Math.round(H*0.069), h:Math.round(H*0.069),
    v:0, yRender:0,
    draw(){ ctx.save(); const a=Math.max(-0.45,Math.min(0.9,(this.v/600)*0.5)); ctx.translate(this.x+this.w/2,this.yRender); ctx.rotate(a); if(birdImg){ ctx.drawImage(birdImg,-this.w/2,-this.h/2,this.w,this.h); } else { ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);} ctx.restore(); },
    step(dt){ this.v+=G*dt; if(this.v>MAX_FALL) this.v=MAX_FALL; this.y+=this.v*dt; },
    flap(){ this.v=LIFT_V0; playFlap(); },
    reset(){ this.y=Math.round(H*0.5); this.v=0; }
  };

  // Semi-fixed timestep + interpolation (smooth 60/165Hz)
  let physicsHz=120, STEP=1/physicsHz, accumulator=0, lastTs=performance.now();
  const MAX_FRAME_DT=0.12, samples=[], targetRates=[60,90,100,120,144,165,180,240];
  function calibrate(dt){ if(samples.length<30){ samples.push(dt); return; } const avg=samples.reduce((a,b)=>a+b,0)/samples.length; const estHz=Math.round(1/avg); let nearest=targetRates[0], diff=1e9; for(const r of targetRates){ const d=Math.abs(estHz-r); if(d<diff){ diff=d; nearest=r; } } physicsHz=(nearest<=60)?120:Math.min(nearest,240); STEP=1/physicsHz; samples.length=30; }

  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT) frameDt=MAX_FRAME_DT; if(frameDt<0) frameDt=0; if(samples.length<30) calibrate(frameDt); lastTs=ts;
    accumulator += frameDt;
    while(accumulator>=STEP){
      if(started && !over){
        stepObstacles(STEP);
        bird.step(STEP);
        if(bird.y+(bird.h-BIRD_INSET)>=H) endGame(null);
        if(bird.y+BIRD_INSET<=0) endGame(null);
      }
      accumulator -= STEP;
    }
    const leftover = over?0:accumulator;

    ctx.clearRect(0,0,W,H);
    drawBackground();
    bird.yRender = bird.y + bird.v*leftover + (over?0:0.5*G*leftover*leftover);
    drawObstaclesInterpolated(leftover);
    bird.draw();

    if(started && !over) collideAndScore(leftover);

    // version tag (bottom-left)
    ctx.fillStyle='rgba(0,0,0,.95)';
    ctx.font='700 16px Montserrat,system-ui';
    ctx.fillText('v'+VERSION, 14, H-14);

    requestAnimationFrame(loop);
  }

  // Game Over + system card
  function endGame(hitStyleIdx){
    if(over) return; over=true; bird.v=0; playHit();
    finalScoreP.textContent = `Score: ${score} â€¢ Best: ${best}`;
    const box=document.getElementById('sysInfoBox'), imgEl=document.getElementById('sysImg'), tEl=document.getElementById('sysTitle'), bEl=document.getElementById('sysBlurb'), specsBox=document.getElementById('sysSpecsBox'), sEl=document.getElementById('sysSpecs'), lEl=document.getElementById('sysLinks');

    if(hitStyleIdx!=null && SYSTEMS[hitStyleIdx]){
      const info=SYSTEMS[hitStyleIdx];
      tEl.textContent=info.title||`System ${hitStyleIdx+1}`;
      bEl.textContent=info.blurb||'';
      lEl.innerHTML = info.tds && info.tds!=='#' ? `<a href="${info.tds}" target="_blank" rel="noopener" style="color:#7dcfff;text-decoration:underline">ðŸ“„ Technical Data Sheet</a>` : '';
      if(info.img && info.img!=='#'){ imgEl.style.opacity='0'; imgEl.onload=()=>{ imgEl.style.opacity='1'; }; imgEl.src=info.img; imgEl.style.display='block'; } else { imgEl.style.display='none'; }
      sEl.innerHTML='';
      if(info.specTable && Array.isArray(info.specTable.headers) && Array.isArray(info.specTable.rows)){
        const headers=info.specTable.headers;
        sEl.innerHTML='<thead><tr>'+headers.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specTable.rows.forEach(row=>{ const tr=document.createElement('tr'); tr.innerHTML=row.map((cell,i)=>`<td${i===0?' style="font-weight:600"':''}>${cell}</td>`).join(''); tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else if(info.specHeaders && info.specs && info.specs.length){
        sEl.innerHTML='<thead><tr>'+info.specHeaders.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specs.forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td style="font-weight:600">${k}</td><td>${v}</td>`; tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else { specsBox.style.display='none'; }
      box.style.display='block';
    } else { box.style.display='none'; imgEl.style.display='none'; }

    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop=0; requestAnimationFrame(()=>{ gameOverCard.scrollTop=0; });
    restartLocked=true; setTimeout(()=>{ restartLocked=false; },1000);
  }

  function startGame(){
    started=true; over=false; restartLocked=false; spawnTimer=0;
    lastScore=score; lastEl.textContent=lastScore;
    score=0; scoreEl.textContent="0";
    obstacles.length=0; bird.reset();

    phase='VERTICALS';
    bufferTime=0; postBuffer=false; challengeQueued=false; verticalsPassed=0;

    startCard.classList.add('hidden'); gameOverCard.classList.add('hidden');
  }

  async function handleTap(e){
    e?.preventDefault?.(); e?.stopPropagation?.();
    await unlockAudio(); // ensure audio is running before actions
    if(!rotBlock.classList.contains('show')){
      if(!started){ startGame(); bird.flap(); return; }
      if(!over){ bird.flap(); return; }
      if(!restartLocked) startGame();
    }
  }

  // Input (multiple listeners to maximize audio unlock chances)
  startCard.addEventListener('click', handleTap, {passive:false});
  startCard.addEventListener('touchstart', handleTap, {passive:false});
  document.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('#gameOverCard')) return;
    if (e.target.closest('#muteBtn, #fsBtn')) return;
    handleTap(e);
  }, {passive:false, capture:true});
  document.addEventListener('keydown', async (e)=>{
    if(e.code==='Space'||e.key===' '){
      await handleTap(e);
    }
  }, {passive:false});

  // Boot
  (async () => {
    try{
      const [bg,birdPic] = await Promise.all([
        loadImageWithTimeout("assets/bg.png"),
        loadImageWithTimeout("assets/bird.png")
      ]);
      bgImg = bg || null; birdImg = birdPic || null;

      const promises=[]; for (const s of PIPE_STYLES_CFG){ promises.push(loadImageWithTimeout(s.bottom.url)); promises.push(loadImageWithTimeout(s.top.url)); }
      const results=await Promise.allSettled(promises);
      const bottoms=[], tops=[]; for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=results[i*2]?.value||null; tops[i]=results[i*2+1]?.value||null; }
      Raw.bottoms=bottoms; Raw.tops=tops; rebuildStyles();
    } finally {
      document.getElementById('loadingOverlay').style.display='none';
      requestAnimationFrame(loop);
    }
  })();
})();
</script>
</body>
</html>
