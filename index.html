<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flappy Mo â€” Local Assets (v1.47p-spriteBird-perf)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  /* Canvas is visually 1920Ã—1080, internal resolution scales dynamically for perf */
  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
    /* removed heavy shadow for perf */
  }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
    scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff; }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff; }
  .hidden{ display:none }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:999 }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  #sysImg {
    max-width:100%; max-height:240px; object-fit:contain;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.1);
    border-radius:10px; margin:10px auto;
    display:none; opacity:0; transition:opacity .25s ease;
  }
  #sysInfoBox, #sysInfoBox * { color:#fff !important; }
  #sysBlurb { white-space:pre-line; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">ðŸ”Š Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">â›¶ Fullscreen</button>

<!-- Overlays -->
<div class="overlay">
  <div id="startCard" class="card">
    <h1>Tap to Start</h1>
    <p>Tap again to flap â€¢ Best is saved</p>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 â€¢ Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>

    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">â€”</span></div>
      <div id="sysBlurb" style="opacity:.95; font-size:13px; margin-bottom:8px">â€”</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<!-- Rotate blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. Turn your device to play.</p>
  </div>
</div>

<script>
(() => {
  const VERSION = '1.47p-spriteBird-perf';
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  // LOGICAL world size (unchanged gameplay)
  const W = 1920, H = 1080;

  // Physics
  const SPEED_MULT = isMobile ? 1.40 : 1.50;
  const G         = 4800 * SPEED_MULT;
  const LIFT_V0   = -1350 * SPEED_MULT;
  const MAX_FALL  = 2200 * SPEED_MULT;
  const SCROLL_PPS=  480 * SPEED_MULT;

  // Pipes
  const PIPE_W    = 180;
  const GAP_MIN   = 310, GAP_MAX = 450;

  // Vertical spacing (all verticals incl. first)
  const VERTICAL_X_GAP = Math.round(SCROLL_PPS * 1.8);
  const FIRST_VERTICAL_LEAD_PIXELS = VERTICAL_X_GAP;

  // Horizontal challenge spacing (after each 10 verticals)
  const CHALLENGE_BARS   = 3;
  const HORIZ_SPACING_X  = Math.round(W * 0.25);
  const HORIZ_MARGIN_Y   = Math.round(H * 0.18);
  const BUFFER_PIXELS    = Math.round(W * 0.06);  // you asked to keep 6%
  const HORIZ_LEAD_PIXELS= Math.round(W * 0.08);

  // Top & bottom grace
  const TOP_OVERLAP_FRAC    = 0.30;
  const BOTTOM_OVERLAP_FRAC = 0.75;

  // Flow / phases
  let phase = 'VERTICALS';
  let bufferTime = 0;
  let challengeQueued = false;
  let verticalsPassed = 0;

  let nextSpawnPx = FIRST_VERTICAL_LEAD_PIXELS;
  let verticalsEnabled = true;

  // Canvas + dynamic internal scale
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = false; // faster & crisp

  // Visual scale (CSS) to fit window
  function fitCSS(){
    const vw = innerWidth;
    const vh = Math.round(window.visualViewport ? visualViewport.height : innerHeight);
    const s = Math.min(vw / W, vh / H);
    canvas.style.transform = `translate(-50%, -50%) scale(${s})`;
  }
  addEventListener('resize', fitCSS, {passive:true});
  window.visualViewport && visualViewport.addEventListener('resize', fitCSS, {passive:true});
  fitCSS();

  // Orientation
  const rotBlock = document.getElementById('rotBlock');
  function checkOrientation(){ rotBlock.classList.toggle('show', innerWidth < innerHeight); }
  addEventListener('resize', checkOrientation, {passive:true}); checkOrientation();

  // UI
  const scoreEl = document.getElementById('scoreVal');
  const lastEl  = document.getElementById('lastVal');
  const bestEl  = document.getElementById('bestVal');
  const startCard   = document.getElementById('startCard');
  const gameOverCard= document.getElementById('gameOverCard');
  const finalScoreP = document.getElementById('finalScoreP');
  const fsBtn = document.getElementById('fsBtn');

  function inFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
  function updateFsBtn(){ fsBtn.textContent = inFullscreen() ? "â¤¢ Exit" : "â›¶ Fullscreen"; }
  fsBtn.addEventListener('click', async (e)=>{
    e.stopPropagation();
    const el=document.documentElement;
    try{
      if(!inFullscreen()){
        await (el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.msRequestFullscreen?.());
      } else {
        await (document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.msExitFullscreen?.());
      }
    }catch(_){}
    updateFsBtn();
  }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  // Scores/state
  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent = best;

  // AUDIO (unchanged, only flap + hit)
  let audioCtx=null, masterGain=null, audioReady=false, muted=false;
  function createAudio(){ if(audioReady) return; const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return; audioCtx=new AC({latencyHint:"interactive"}); masterGain=audioCtx.createGain(); masterGain.gain.value=muted?0:0.85; masterGain.connect(audioCtx.destination); audioReady=true; }
  async function unlockAudio(){ try{ createAudio(); if(audioCtx && audioCtx.state!=='running'){ await audioCtx.resume(); } }catch(_){ } }
  function setMuted(m){ muted=m; if(masterGain) masterGain.gain.value=muted?0:0.85; const b=document.getElementById('muteBtn'); b.textContent = muted ? "ðŸ”‡ Muted" : "ðŸ”Š Sound"; b.setAttribute("aria-pressed", String(muted)); }
  document.getElementById('muteBtn').addEventListener('click', async (e)=>{ e.stopPropagation(); await unlockAudio(); setMuted(!muted); });
  function envGain(d=0.25,a=0.008,v=1){ if(!audioReady) return null; const g=audioCtx.createGain(); const t=audioCtx.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+a); g.gain.exponentialRampToValueAtTime(0.0001,t+d); return g; }
  function woosh(d=0.22,c=1200,v=0.35){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<n;i++) data[i]=(Math.random()*2-1)*0.35; const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=c; const g=envGain(d,0.01,v); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  function crash(d=1.1){ if(!audioReady||muted) return; const n=Math.max(1,audioCtx.sampleRate*d); const buf=audioCtx.createBuffer(1,n,audioCtx.sampleRate); const data=buf.getChannelData(0); let b0=0,b1=0,b2=0; for(let i=0;i<n;i++){ const w=Math.random()*2-1; b0=0.997*b0+w*0.03; b1=0.985*b1+w*0.05; b2=0.95*b2+w*0.07; data[i]=(b0+b1+b2)*0.65; } const src=audioCtx.createBufferSource(); src.buffer=buf; const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=700; const g=envGain(d,0.02,0.45); if(!g)return; src.connect(lp); lp.connect(g); g.connect(masterGain); src.start(); src.stop(audioCtx.currentTime+d+0.05); }
  const playFlap = ()=> woosh();
  const playHit  = ()=> crash();

  // Assets
  function loadImageWithTimeout(src,timeout=6000){ return new Promise((res)=>{ if(!src){ res(null); return; } const img=new Image(); img.referrerPolicy='no-referrer'; let done=false; const finish=v=>{ if(done)return; done=true; res(v||null); }; const t=setTimeout(()=>finish(null),timeout); img.onload=()=>{ clearTimeout(t); finish(img); }; img.onerror=()=>{ clearTimeout(t); finish(null); }; img.src=src; }); }

  // Bird sprite support
  const BIRD_SPRITE_URL    = "assets/bird-sprite.png";
  const BIRD_SPRITE_FRAMES = 4;
  const BIRD_SPRITE_FPS    = 10;
  let birdSprite=null, birdFallbackImg=null;

  let bgImg=null;

  // Pipe styles (same as before)
  const PIPE_STYLES_CFG = [
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] };
  const Styles=[];
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=false; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#3a3a3a"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.imageSmoothingEnabled=false; g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return { cap:ph, body:ph }; }
    const scale = drawW / (img.naturalWidth || img.width);
    const scaledH = Math.max(1, Math.round((img.naturalHeight || img.height) * scale));
    const capH    = Math.max(1, Math.round(capPxSrc * scale));
    const full = makeScaledCanvas(img, drawW, scaledH);
    const cap  = document.createElement("canvas");
    const body = document.createElement("canvas");
    cap.width = drawW; cap.height = Math.min(capH, scaledH);
    body.width = drawW; body.height = Math.max(1, scaledH - cap.height);
    const cg = cap.getContext("2d"), bg = body.getContext("2d");
    cg.imageSmoothingEnabled = bg.imageSmoothingEnabled = false;
    if (capFrom === "top") {
      cg.drawImage(full, 0, 0, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, cap.height, drawW, body.height, 0, 0, drawW, body.height);
    } else {
      cg.drawImage(full, 0, scaledH - cap.height, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, 0, drawW, body.height, 0, 0, drawW, body.height);
    }
    return { cap, body };
  }
  function rebuildStyles(){
    Styles.length=0;
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      const cfg=PIPE_STYLES_CFG[i];
      const bot=Raw.bottoms[i], top=Raw.tops[i];
      const drawW = Math.round(PIPE_W * (cfg.scale || 1));
      const bottom = buildCapBodyPx(bot, drawW, cfg.bottom.capPx, cfg.bottom.capFrom);
      const topset = buildCapBodyPx(top, drawW, cfg.top.capPx,   cfg.top.capFrom);
      Styles.push({ name:cfg.name, bottom, top:topset, drawW, botImg: bot });
    }
  }

  // Systems (same content as earlier â€“ omitted here for brevity)
  const SYSTEMS=[ /* â€”â€”â€” keep your SYSTEMS array from the last working version here â€”â€”â€” */ ];

  // Obstacles
  const obstacles=[];
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function buildVerticalSprite(sty, top, gap, w){
    const c=document.createElement('canvas'); c.width=w; c.height=H;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=false;
    if(top>0){
      const cap=sty.top.cap, body=sty.top.body;
      const capH=Math.min(cap.height,top), bodyH=top-capH;
      if(bodyH>0){
        let y=top-capH-body.height;
        while(y>=0){ g.drawImage(body,0,y,w,body.height); y-=body.height; }
        const rem=(top-capH)%body.height;
        if(rem>0) g.drawImage(body,0,body.height-rem,body.width,rem,0,0,w,rem);
      }
      g.drawImage(cap,0,top-capH,w,capH);
    }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){
      const cap=sty.bottom.cap, body=sty.bottom.body;
      const capH=Math.min(cap.height,bottomH);
      g.drawImage(cap,0,by,w,capH);
      let y=by+capH, filled=0, remain=bottomH-capH;
      while(filled+body.height<=remain){ g.drawImage(body,0,y,w,body.height); y+=body.height; filled+=body.height; }
      const left=remain-filled;
      if(left>0) g.drawImage(body,0,0,body.width,left,0,y,w,left);
    }
    return c;
  }
  function buildHorizontalSprite(sty){
    const img=sty.botImg, drawW=sty.drawW;
    const c=document.createElement('canvas'); c.width=Math.max(1, drawW*6); c.height=drawW;
    const g=c.getContext('2d'); g.imageSmoothingEnabled=false;
    if(img){
      const scale=drawW/(img.naturalWidth||img.width);
      const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
      c.width=scaledH; c.height=drawW;
      g.translate(0,drawW); g.rotate(-Math.PI/2);
      g.drawImage(img,0,0,img.naturalWidth||img.width,img.naturalHeight||img.height,0,0,drawW,scaledH);
    }else{
      g.fillStyle="#2e8b57"; g.fillRect(0,0,c.width,c.height);
    }
    return c;
  }
  function spawnVerticalAt(xPos){
    if(!Styles.length) return;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin, minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin); if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap); if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex], w=sty.drawW;
    const sprite=buildVerticalSprite(sty,top,gap,w);
    obstacles.push({type:'V',x:xPos,top,gap,w,styleIndex,scored:false,sprite});
  }
  const spawnVertical=()=>spawnVerticalAt(W);
  function spawnHorizontalAt(xStart){
    if(!Styles.length) return;
    const styleIndex=Math.floor(Math.random()*Styles.length), sty=Styles[styleIndex];
    const sprite=buildHorizontalSprite(sty);
    const w=sprite.width, h=sty.drawW, y=randInt(HORIZ_MARGIN_Y,H-HORIZ_MARGIN_Y-h);
    obstacles.push({type:'H',x:xStart,y,w,h,styleIndex,scored:false,sprite});
  }
  function spawnHorizontalChallenge(){
    const firstX = W + HORIZ_LEAD_PIXELS;
    let lastRight=0;
    for(let i=0;i<CHALLENGE_BARS;i++){
      const x=(i===0?firstX:lastRight+HORIZ_SPACING_X);
      spawnHorizontalAt(x);
      const last=obstacles[obstacles.length-1];
      lastRight = last.x + last.w;
    }
  }
  function stepObstacles(dt){
    for(const o of obstacles){ o.x -= SCROLL_PPS*dt; }
    for(let i=obstacles.length-1;i>=0;i--) if(obstacles[i].x+obstacles[i].w<=0) obstacles.splice(i,1);

    if(phase==='VERTICALS'){
      if(verticalsEnabled){
        nextSpawnPx -= SCROLL_PPS * dt;
        while(nextSpawnPx <= 0){ spawnVertical(); nextSpawnPx += VERTICAL_X_GAP; }
      }
      if(challengeQueued){
        phase='PRE_BUFFER'; verticalsEnabled=false;
        nextSpawnPx = VERTICAL_X_GAP;
        bufferTime = BUFFER_PIXELS / SCROLL_PPS;
        challengeQueued=false;
      }
      return;
    }
    if(phase==='PRE_BUFFER'){ bufferTime -= dt; if(bufferTime<=0){ phase='H_CHALLENGE'; spawnHorizontalChallenge(); } return; }
    if(phase==='H_CHALLENGE'){ if(obstacles.findIndex(o=>o.type==='H')===-1){ phase='POST_BUFFER'; bufferTime = BUFFER_PIXELS / SCROLL_PPS; } return; }
    if(phase==='POST_BUFFER'){ bufferTime -= dt; if(bufferTime<=0){ phase='VERTICALS'; verticalsEnabled=true; } return; }
  }
  function scoreUp(){ score++; scoreEl.textContent=score; if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); } }
  function collideAndScore(leftover){
    const BIRD_INSET = 8, GAP_FORGIVE = 12;
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.type==='V'){
        const overlapX=(bx2>xR)&&(bx1<xR+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){ endGame(o.styleIndex); return true; }
        }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); verticalsPassed++; if(verticalsPassed>0 && verticalsPassed%10===0){ if(phase==='VERTICALS') challengeQueued=true; } }
      } else {
        const overlapX=(bx2>xR)&&(bx1<xR+o.w), overlapY=(by2>o.y)&&(by1<o.y+o.h);
        if(overlapX && overlapY){ endGame(o.styleIndex); return true; }
        if(!o.scored && (xR+o.w)<bx1){ o.scored=true; scoreUp(); }
      }
    }
    return false;
  }
  function drawObstaclesInterpolated(leftover){
    for(const o of obstacles){
      const xR=o.x - SCROLL_PPS*leftover;
      if(o.sprite) ctx.drawImage(o.sprite, xR, (o.type==='H'?o.y:0), o.w, (o.type==='H'?o.h:H));
    }
  }

  // Background
  function drawBackground(){ if(bgImg) ctx.drawImage(bgImg,0,0,W,H); else { ctx.fillStyle="#d9f4ff"; ctx.fillRect(0,0,W,H); } }

  // Bird
  const bird={
    x:Math.round(W*0.167), y:Math.round(H*0.5),
    w:Math.round(H*0.069), h:Math.round(H*0.069),
    v:0, yRender:0, animTime:0,
    draw(frameDt){
      const angle = Math.max(-0.45, Math.min(0.9, (this.v/600)*0.5));
      this.animTime += frameDt;
      ctx.save();
      ctx.translate(this.x+this.w/2, this.yRender);
      ctx.rotate(angle);
      if (birdSprite && birdSprite.complete && birdSprite.naturalWidth) {
        const frames=BIRD_SPRITE_FRAMES, fps=BIRD_SPRITE_FPS;
        const frameW=Math.floor(birdSprite.naturalWidth/frames), frameH=birdSprite.naturalHeight;
        const idx=Math.floor(this.animTime*fps)%frames, sx=idx*frameW;
        ctx.drawImage(birdSprite, sx,0,frameW,frameH, -this.w/2,-this.h/2, this.w,this.h);
      } else if (birdFallbackImg && birdFallbackImg.complete && birdFallbackImg.naturalWidth) {
        ctx.drawImage(birdFallbackImg, -this.w/2, -this.h/2, this.w, this.h);
      } else {
        ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);
      }
      ctx.restore();
    },
    step(dt){ this.v+=G*dt; if(this.v>MAX_FALL) this.v=MAX_FALL; this.y+=this.v*dt; },
    flap(){ this.v=LIFT_V0; woosh(); },
    reset(){ this.y=Math.round(H*0.5); this.v=0; this.animTime=0; }
  };

  // Semi-fixed timestep + dynamic render scale
  let physicsHz=120, STEP=1/physicsHz, accumulator=0, lastTs=performance.now();
  let INTERNAL_SCALE = 1;               // dynamic internal resolution scale
  let transformSet = false;
  const MAX_FRAME_DT=0.12, samples=[], targetRates=[60,90,100,120,144,165,180,240];
  function calibrate(dt){
    if(samples.length<30){ samples.push(dt); return; }
    const avg=samples.reduce((a,b)=>a+b,0)/samples.length;
    const estHz=Math.round(1/avg);
    let nearest=targetRates[0], diff=1e9;
    for(const r of targetRates){ const d=Math.abs(estHz-r); if(d<diff){ diff=d; nearest=r; } }
    physicsHz = 120;            // cap physics at 120Hz for stability
    STEP = 1/physicsHz;
    // Dynamic internal resolution: drop to 75% if ~60Hz
    INTERNAL_SCALE = (nearest <= 60) ? 0.75 : 1.0;
    // Apply internal canvas size + transform once
    const targetW = Math.max(1, Math.round(W * INTERNAL_SCALE));
    const targetH = Math.max(1, Math.round(H * INTERNAL_SCALE));
    if (canvas.width !== targetW || canvas.height !== targetH) {
      canvas.width = targetW; canvas.height = targetH;
      ctx.imageSmoothingEnabled = false;
      ctx.setTransform(INTERNAL_SCALE, 0, 0, INTERNAL_SCALE, 0, 0); // map logical WÃ—H to internal pixels
    }
    transformSet = true;
    samples.length=30; // keep rolling average steady
  }

  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT) frameDt=MAX_FRAME_DT; if(frameDt<0) frameDt=0;
    if(!transformSet) calibrate(frameDt);
    lastTs=ts;

    accumulator += frameDt;
    while(accumulator>=STEP){
      if(started && !over){
        stepObstacles(STEP);
        bird.step(STEP);

        const INSET = 8;
        bird.yRender = bird.y;
        const topAllowancePx = bird.h * TOP_OVERLAP_FRAC;
        if(bird.yRender - (bird.h/2 - INSET) <= -topAllowancePx) endGame(null);
        const bottomAllowancePx = bird.h * BOTTOM_OVERLAP_FRAC;
        if(bird.yRender + (bird.h/2 - INSET) >= H + bottomAllowancePx) endGame(null);
      }
      accumulator -= STEP;
    }
    const leftover = over?0:accumulator;

    // Clear + draw (logical coords; transform handles scale)
    ctx.clearRect(0,0,W,H);
    drawBackground();
    bird.yRender = bird.y + bird.v*leftover + (over?0:0.5*G*leftover*leftover);
    drawObstaclesInterpolated(leftover);
    bird.draw(frameDt);

    if(started && !over) collideAndScore(leftover);

    // version
    ctx.fillStyle='rgba(120,120,120,0.95)';
    ctx.font='700 8px Montserrat,system-ui';
    ctx.fillText('v'+VERSION, 14, H-14);

    requestAnimationFrame(loop);
  }

  // Game over / system card
  function endGame(hitStyleIdx){
    if(over) return; over=true; bird.v=0; playHit();
    finalScoreP.textContent = `Score: ${score} â€¢ Best: ${best}`;
    const box=document.getElementById('sysInfoBox'), imgEl=document.getElementById('sysImg'), tEl=document.getElementById('sysTitle'), bEl=document.getElementById('sysBlurb'), specsBox=document.getElementById('sysSpecsBox'), sEl=document.getElementById('sysSpecs'), lEl=document.getElementById('sysLinks');

    if(hitStyleIdx!=null && SYSTEMS[hitStyleIdx]){
      const info=SYSTEMS[hitStyleIdx];
      tEl.textContent=info.title||`System ${hitStyleIdx+1}`;
      bEl.textContent=info.blurb||'';
      lEl.innerHTML = info.tds && info.tds!=='#' ? `<a href="${info.tds}" target="_blank" rel="noopener" style="color:#7dcfff;text-decoration:underline">ðŸ“„ Technical Data Sheet</a>` : '';
      if(info.img && info.img!=='#'){ imgEl.style.opacity='0'; imgEl.onload=()=>{ imgEl.style.opacity='1'; }; imgEl.src=info.img; imgEl.style.display='block'; } else { imgEl.style.display='none'; }
      sEl.innerHTML='';
      if(info.specTable && Array.isArray(info.specTable.headers) && Array.isArray(info.specTable.rows)){
        sEl.innerHTML='<thead><tr>'+info.specTable.headers.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specTable.rows.forEach(row=>{ const tr=document.createElement('tr'); tr.innerHTML=row.map((cell,i)=>`<td${i===0?' style="font-weight:600"':''}>${cell}</td>`).join(''); tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else if(info.specHeaders && info.specs && info.specs.length){
        sEl.innerHTML='<thead><tr>'+info.specHeaders.map(h=>`<th>${h}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tbody=sEl.querySelector('tbody');
        info.specs.forEach(([k,v])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td style="font-weight:600">${k}</td><td>${v}</td>`; tbody.appendChild(tr); });
        specsBox.style.display='block';
      } else { specsBox.style.display='none'; }
      box.style.display='block';
    } else { box.style.display='none'; imgEl.style.display='none'; }

    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop=0; requestAnimationFrame(()=>{ gameOverCard.scrollTop=0; });
    restartLocked=true; setTimeout(()=>{ restartLocked=false; },1000);
  }

  function startGame(){
    started=true; over=false; restartLocked=false;
    lastScore=score; lastEl.textContent=lastScore;
    score=0; scoreEl.textContent="0";
    obstacles.length=0; bird.reset();

    phase='VERTICALS'; bufferTime=0; challengeQueued=false; verticalsPassed=0;
    nextSpawnPx = FIRST_VERTICAL_LEAD_PIXELS; verticalsEnabled = true;

    startCard.classList.add('hidden'); gameOverCard.classList.add('hidden');
  }

  async function handleTap(e){
    e?.preventDefault?.(); e?.stopPropagation?.();
    await unlockAudio();
    if(!rotBlock.classList.contains('show')){
      if(!started){ startGame(); bird.flap(); return; }
      if(!over){ bird.flap(); return; }
      if(!restartLocked) startGame();
    }
  }

  // Input
  startCard.addEventListener('click', handleTap, {passive:false});
  startCard.addEventListener('touchstart', handleTap, {passive:false});
  document.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('#gameOverCard')) return;
    if (e.target.closest('#muteBtn, #fsBtn')) return;
    handleTap(e);
  }, {passive:false, capture:true});
  document.addEventListener('keydown', async (e)=>{
    if(e.code==='Space'||e.key===' '){ await handleTap(e); }
  }, {passive:false});

  // Boot (draw immediately with fallbacks)
  requestAnimationFrame(loop);

  (async () => {
    try{
      const [sprite, single, bg] = await Promise.all([
        loadImageWithTimeout(BIRD_SPRITE_URL),
        loadImageWithTimeout("assets/bird.png"),
        loadImageWithTimeout("assets/bg.png"),
      ]);
      birdSprite = sprite || null;
      birdFallbackImg = (!birdSprite && single) ? single : null;
      bgImg = bg || null;

      const promises=[]; for (const s of PIPE_STYLES_CFG){ promises.push(loadImageWithTimeout(s.bottom.url)); promises.push(loadImageWithTimeout(s.top.url)); }
      const results=await Promise.allSettled(promises);
      const bottoms=[], tops=[]; for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=results[i*2]?.value||null; tops[i]=results[i*2+1]?.value||null; }
      Raw.bottoms=bottoms; Raw.tops=tops; rebuildStyles();
    }catch(_){ rebuildStyles(); }
  })();
})();
</script>
</body>
</html>
