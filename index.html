<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ROCKET MO — v2.09 (audio -20%)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.86); --bg:#0b0d10; }
  *{ box-sizing:border-box }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent }
  #game{ position:fixed; top:50%; left:50%; width:1920px; height:1080px; transform:translate(-50%,-50%) scale(1); transform-origin:center center; background:#000; touch-action:none; image-rendering:auto; border-radius:14px; border:1px solid rgba(255,255,255,.08) }
  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:rgba(20,24,28,.8); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }
  .badge.clickable{ pointer-events:auto; cursor:pointer; user-select:none }
  .god-pill{ background:#ffc400; color:#1a1e26; border:1px solid rgba(0,0,0,.25) }
  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .splash{ pointer-events:auto; width:min(720px,94vw); background:rgba(20,24,28,.86); color:#fff; border-radius:18px; border:1px solid rgba(255,255,255,.12); backdrop-filter:blur(6px); box-shadow:0 22px 60px rgba(0,0,0,.55); padding:28px 24px 18px; text-align:center }
  .splash h1{ margin:0 0 8px; font-weight:800; font-size:clamp(28px,7.2vw,56px); background:linear-gradient(180deg,#ffd54a 0%,#fff7c5 35%,#ff7a3a 100%); -webkit-background-clip:text; background-clip:text; color:transparent }
  .splash .hint{ opacity:.9; font-size:12px; margin-top:6px }
  .start-btn{ margin-top:16px; pointer-events:auto; cursor:pointer; border:1px solid rgba(255,255,255,.18); background:#ff7a3a; color:#1a1e26; font-weight:800; border-radius:12px; padding:10px 16px; font-size:16px; box-shadow:0 8px 24px rgba(0,0,0,.35) }
  .card{ pointer-events:auto; color:#fff; background:rgba(20,24,28,.86); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:20px 22px; text-align:center; backdrop-filter:blur(6px); max-width:min(92vw,560px); max-height:calc(100vh - 64px); overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800; color:#fff }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px); color:#fff }
  .hidden{ display:none }
  #sysImg{ max-width:100%; max-height:240px; object-fit:contain; margin:10px auto; display:none; opacity:0; transition:opacity .25s ease; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px }
  #sysSpecs th,#sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.25); padding:6px; text-align:left; color:#fff }
  #sysSpecs th{ font-weight:800 }
  #sysSpecs td:first-child{ font-weight:600 }
  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:9; pointer-events:none }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div id="lastBadge" class="badge clickable" title="Tap 10x to toggle GOD mode">Last: <span id="lastVal">0</span></div>
  <div class="badge">Best: <span id="bestVal">0</span></div>
  <div id="muteBadge" class="badge clickable" title="Toggle sound">🔊</div>
  <div id="godPill" class="badge god-pill hidden">GOD</div>
</div>

<!-- Overlays -->
<div class="overlay">
  <div id="splash" class="splash" tabindex="0" aria-label="Title Screen">
    <h1>ROCKET MO</h1>
    <div class="hint">Tap anywhere or press Space/Enter • Best is saved</div>
    <button id="startBtn" class="start-btn">Start</button>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 • Best: 0</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>
    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">—</span></div>
      <div id="sysBlurb" style="opacity:.95; font-size:13px; margin-bottom:8px">—</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
    </div>
  </div>
</div>

<!-- Landscape blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. You can still start from here.</p>
  </div>
</div>

<script>
(() => {
  const VERSION='2.09';
  const isMobile=/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  /* Canvas fit */
  const W=1920,H=1080;
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d',{alpha:false});
  ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  function fitCSS(){ const vw=innerWidth, vh=Math.round(window.visualViewport?visualViewport.height:innerHeight); const s=Math.min(vw/W, vh/H); canvas.style.transform=`translate(-50%,-50%) scale(${Math.round(s*100)/100})`; }
  addEventListener('resize',fitCSS,{passive:true}); window.visualViewport&&visualViewport.addEventListener('resize',fitCSS,{passive:true}); fitCSS();
  function checkOrientation(){ const rb=document.getElementById('rotBlock'); rb.classList.toggle('show', isMobile && innerWidth<innerHeight); }
  addEventListener('resize',checkOrientation,{passive:true}); checkOrientation();

  /* ================= LOW-LATENCY AUDIO (Web Audio) ================= */
  const MUTE_KEY='flappyMoMute';
  const MASTER_GAIN = 0.8; // 20% lower global volume
  let muted = localStorage.getItem(MUTE_KEY)==='1';
  const muteBadge=document.getElementById('muteBadge');
  function updateMuteBadge(){ muteBadge.textContent = muted ? '🔇' : '🔊'; }
  updateMuteBadge();

  const AudioEngine = (() => {
    const Ctx = window.AudioContext||window.webkitAudioContext;
    const ctx = new Ctx({latencyHint:'interactive'});
    const master = ctx.createGain(); 
    master.gain.value = muted ? 0 : MASTER_GAIN; // apply -20% here
    master.connect(ctx.destination);
    const buffers = Object.create(null);
    async function fetchDecode(url){
      try{
        const res=await fetch(url,{cache:'force-cache'});
        if(!res.ok) return null;
        const arr=await res.arrayBuffer();
        return await new Promise((resolve)=>{
          const cbOk=b=>resolve(b), cbBad=()=>resolve(null);
          const p=ctx.decodeAudioData(arr,cbOk,cbBad);
          if(p && p.then) p.then(resolve).catch(()=>resolve(null));
        });
      }catch(e){ return null; }
    }
    async function load(name, candidates){
      for(const u of candidates){
        const b=await fetchDecode(u);
        if(b){ buffers[name]=b; return true; }
      }
      console.warn('[audio] not found for',name,candidates);
      return false;
    }
    function play(name, vol=1){
      const b=buffers[name]; if(!b) return;
      const t = Math.max(ctx.currentTime, 0) + 0.000001;
      const src = ctx.createBufferSource(); src.buffer=b;
      const g = ctx.createGain(); g.gain.value = muted ? 0 : Math.max(0,Math.min(1,vol));
      src.connect(g); g.connect(master);
      try{ src.start(t); }catch(_){}
    }
    async function resume(){ if(ctx.state!=='running'){ try{ await ctx.resume(); }catch(_){}} }
    function setMuted(m){ 
      muted=!!m; localStorage.setItem(MUTE_KEY, muted?'1':'0'); updateMuteBadge(); 
      master.gain.value = muted ? 0 : MASTER_GAIN; // keep master at -20% when unmuted
    }
    function warm(){
      try{
        const b = ctx.createBuffer(1, Math.max(1,Math.floor(ctx.sampleRate*0.02)), ctx.sampleRate);
        const s = ctx.createBufferSource(); s.buffer=b;
        const g = ctx.createGain(); g.gain.value=0;
        s.connect(g); g.connect(master); s.start();
      }catch(_){}
    }
    return {ctx,load,play,resume,setMuted,warm};
  })();

  const audioPaths = (folder,id)=>[
    `assets/audio/${folder}/${id}.ogg`,
    `assets/audio/${folder}/${id}.mp3`,
    `assets/${id}.ogg`,
    `assets/${id}.mp3`,
  ];
  const audioReady = Promise.all([
    AudioEngine.load('flap',    audioPaths('sfx','sfx_flap')),
    AudioEngine.load('hit',     audioPaths('sfx','sfx_hit')),
    AudioEngine.load('score',   audioPaths('sfx','sfx_score')),
    AudioEngine.load('uiStart', audioPaths('ui','ui_start')),
    AudioEngine.load('uiOver',  audioPaths('ui','ui_gameover')),
  ]).then(()=>true);

  muteBadge.addEventListener('click', (e)=>{ e.stopPropagation(); AudioEngine.setMuted(!muted); }, {passive:false});

  let audioUnlocked=false;
  function unlockAudio(){ if(audioUnlocked) return; audioUnlocked=true; AudioEngine.resume(); AudioEngine.warm(); }

  /* ===================== Physics & Game Params ===================== */
  let physicsHz=isMobile?90:120, STEP=1/physicsHz, accumulator=0, lastTs=performance.now();
  const MAX_FRAME_DT=0.12;

  const SPEED_MULT=isMobile?1.40:1.50;
  const G=4800*SPEED_MULT, LIFT_V0=-1250*SPEED_MULT, MAX_FALL=2200*SPEED_MULT;
  const baseScroll=isMobile?480:440; const SCROLL_PPS=baseScroll*SPEED_MULT;

  const VERTICAL_X_GAP=Math.round(SCROLL_PPS*1.8);
  const FIRST_VERTICAL_LEAD=VERTICAL_X_GAP;

  const PIPE_W=180, GAP_MIN=310, GAP_MAX=450;
  const TOP_OVERLAP_FRAC=0.30, BOTTOM_OVERLAP_FRAC=0.75;
  const BIRD_INSET=8, GAP_FORGIVE=12;

  /* Bird sprite */
  const BIRD_SPRITE_FRAMES=4, BIRD_SPRITE_FPS=12, BIRD_SPRITE_SCALE=1;
  const BIRD_ANCHOR_X_FRAC=0.58, BIRD_ANCHOR_Y_FRAC=0.50;
  let birdSprite=null, birdFallbackImg=null, bgImg=null;

  const bird={
    x:Math.round(W*0.167),
    y:Math.round(H*0.5),
    w:Math.round(H*0.069),
    h:Math.round(H*0.069),
    v:0, yRender:0, animTime:0,
    yPrev:0, vPrev:0,
    flap(){ if(state!=='playing') return; this.v=LIFT_V0; AudioEngine.play('flap',0.9); },
    reset(){ this.y=Math.round(H*0.5); this.v=0; this.animTime=0; this.yPrev=this.y; this.vPrev=this.v; },
    draw(angleV){
      const ang=Math.max(-0.45,Math.min(0.9,(angleV/600)*0.5));
      ctx.save(); ctx.translate(this.x+this.w/2, this.yRender); ctx.rotate(ang);
      if(birdSprite && birdSprite.complete && birdSprite.naturalWidth){
        const fw=Math.floor(birdSprite.naturalWidth/BIRD_SPRITE_FRAMES), fh=birdSprite.naturalHeight;
        const idx=Math.floor(this.animTime*BIRD_SPRITE_FPS)%BIRD_SPRITE_FRAMES, sx=idx*fw;
        const aspect=fw/fh, drawH=this.h, drawW=drawH*aspect*BIRD_SPRITE_SCALE;
        const ax=drawW*BIRD_ANCHOR_X_FRAC, ay=drawH*BIRD_ANCHOR_Y_FRAC;
        ctx.drawImage(birdSprite, sx,0,fw,fh, -ax,-ay, drawW,drawH);
      } else if(birdFallbackImg && birdFallbackImg.complete && birdFallbackImg.naturalWidth){
        ctx.drawImage(birdFallbackImg, -this.w/2, -this.h/2, this.w, this.h);
      } else { ctx.fillStyle="#fff"; ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h); }
      ctx.restore();
    }
  };

  /* Background */
  function loadImageWithTimeout(src,timeout=6000){
    return new Promise((res)=>{ if(!src){ res(null); return; }
      const img=new Image(); img.referrerPolicy='no-referrer';
      let done=false; const finish=v=>{ if(done)return; done=true; res(v||null); };
      const t=setTimeout(()=>finish(null),timeout);
      img.onload=()=>{ clearTimeout(t); finish(img); };
      img.onerror=()=>{ clearTimeout(t); finish(null); };
      img.src=src;
    });
  }
  let bgCache=null;
  function buildBgCache(){ const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
    const g1=g.createLinearGradient(0,0,0,H); g1.addColorStop(0,'#0f1116'); g1.addColorStop(1,'#1a1e26'); g.fillStyle=g1; g.fillRect(0,0,W,H);
    const r1=g.createRadialGradient(W*0.16,H*0.25,50, W*0.16,H*0.25,420); r1.addColorStop(0,'rgba(255,210,90,0.18)'); r1.addColorStop(1,'rgba(255,210,90,0)'); g.fillStyle=r1; g.fillRect(0,0,W,H);
    const r2=g.createRadialGradient(W*0.85,H*0.35,50, W*0.85,H*0.35,520); r2.addColorStop(0,'rgba(255,120,60,0.14)'); r2.addColorStop(1,'rgba(255,120,60,0)'); g.fillStyle=r2; g.fillRect(0,0,W,H);
    return c; }
  function drawBackground(){ if(bgImg){ ctx.drawImage(bgImg,0,0,W,H); return; } if(!bgCache) bgCache=buildBgCache(); ctx.drawImage(bgCache,0,0); }
  function drawVersionTag(){ ctx.fillStyle='rgba(150,150,150,.95)'; ctx.font='700 10px Montserrat,system-ui'; ctx.fillText('v'+VERSION, 14, H-14); }

  /* Pipe art build helpers */
  const PIPE_STYLES_CFG=[
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"}, top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];
  const Raw={ bottoms:[], tops:[] }, Styles=[];

  function makeScaledCanvas(img,w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#2e8b57"; g.fillRect(0,0,w,h); } return c; }
  function buildCapBodyPx(img,drawW,capPxSrc,capFrom="top"){
    if(!img){ const ph=makeScaledCanvas(null,drawW,120); return {cap:ph, body:ph}; }
    const scale=drawW/(img.naturalWidth||img.width);
    const scaledH=Math.max(1,Math.round((img.naturalHeight||img.height)*scale));
    const capH=Math.max(1,Math.round(capPxSrc*scale));
    const full=makeScaledCanvas(img,drawW,scaledH);
    const cap=document.createElement("canvas"), body=document.createElement("canvas");
    cap.width=drawW; cap.height=Math.min(capH,scaledH);
    body.width=drawW; body.height=Math.max(1,scaledH-cap.height);
    const cg=cap.getContext("2d"), bg=body.getContext("2d"); cg.imageSmoothingEnabled=bg.imageSmoothingEnabled=true;
    if(capFrom==="top"){ cg.drawImage(full,0,0,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,cap.height,drawW,body.height,0,0,drawW,body.height); }
    else { cg.drawImage(full,0,scaledH-cap.height,drawW,cap.height,0,0,drawW,cap.height); bg.drawImage(full,0,0,drawW,body.height,0,0,drawW,body.height); }
    return { cap, body };
  }
  function drawBodyTiled(g,tile,x,yStart,totalH,w,mode){
    const th=tile.height; if(totalH<=0||th<=0) return;
    if(mode==="topUp"){ let y=totalH-th; while(y>=0){ g.drawImage(tile,x,y,w,th); y-=th; } const rem=totalH%th; if(rem>0) g.drawImage(tile,0,th-rem,tile.width,rem,x,0,w,rem); }
    else { let y=yStart, end=yStart+totalH; while(y+th<=end){ g.drawImage(tile,x,y,w,th); y+=th; } const left=end-y; if(left>0) g.drawImage(tile,0,0,tile.width,left,x,y,w,left); }
  }
  function makeVerticalSprite(sty,top,gap,w){
    const c=document.createElement('canvas'); c.width=w; c.height=H; const g=c.getContext('2d'); g.imageSmoothingEnabled=true;
    if(top>0){ const cap=sty.top.cap, body=sty.top.body; const capH=Math.min(cap.height,top), bodyH=top-capH; if(bodyH>0) drawBodyTiled(g,body,0,0,bodyH,w,"topUp"); g.drawImage(cap,0,top-capH,w,capH); }
    const by=top+gap, bottomH=H-by;
    if(bottomH>0){ const cap=sty.bottom.cap, body=sty.bottom.body; const capH=Math.min(cap.height,bottomH); g.drawImage(cap,0,by,w,capH); const remain=bottomH-capH; if(remain>0) drawBodyTiled(g,body,0,by+capH,remain,w,"bottomDown"); }
    return c;
  }
  function rotateLeftCanvas(srcCanvas){ const c=document.createElement('canvas'); c.width=srcCanvas.height; c.height=srcCanvas.width; const g=c.getContext('2d'); g.imageSmoothingEnabled=true; g.translate(0,c.height); g.rotate(-Math.PI/2); g.drawImage(srcCanvas,0,0); return c; }
  function scaleCanvasToHeight(srcCanvas, targetH){ const scale=targetH/srcCanvas.height; const w=Math.max(1,Math.round(srcCanvas.width*scale)); const c=document.createElement('canvas'); c.width=w; c.height=targetH; const g=c.getContext('2d'); g.imageSmoothingEnabled=true; g.drawImage(srcCanvas,0,0,w,targetH); return c; }

  /* WORLD + scheduler */
  const obstacles=[];
  const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  const BUFFER_PIXELS = Math.round(W*0.04);
  const H_GAP_TIME    = 0.90;
  const H_GAP_MIN     = Math.round((H*0.069)*2.2);
  const H_LANES       = [ Math.round(H*0.30), Math.round(H*0.52), Math.round(H*0.74) ];

  let worldScroll=0;
  let xCursor=W+FIRST_VERTICAL_LEAD;
  let verticalCount=0;

  const AHEAD_LIMIT=Math.round(W*2.2);

  const MODE_VERT='VERT', MODE_HSEG='HSEG';
  let spawnMode=MODE_VERT;
  let reservedUntilX=0;

  function maxVerticalRightEdge(minX){
    let m=minX;
    for(const o of obstacles){ if(o.type==='V'){ const r=o.x+o.w; if(r>m) m=r; } }
    return m;
  }

  function scheduleVertical(xPos){
    const idx=Math.floor(Math.random()*Styles.length), sty=Styles[idx], w=sty.drawW;
    const margin=Math.round(H*0.10), maxSection=Math.round(H*0.45);
    const minGapRequired=H-2*maxSection-2*margin;
    const minGap=Math.max(GAP_MIN,Math.min(GAP_MAX,Math.max(0,Math.floor(minGapRequired))));
    const gap=randInt(minGap,GAP_MAX);
    let top=randInt(margin,H-gap-margin);
    if(top>maxSection) top=maxSection;
    let bottomH=H-(top+gap);
    if(bottomH>maxSection) top=H-gap-maxSection;
    top=Math.max(margin,Math.min(top,H-gap-margin));
    obstacles.push({ type:'V', x:xPos, top, gap, w, styleIndex:idx, scored:false, sprite:makeVerticalSprite(sty,top,gap,w) });
  }

  function scheduleHorizontalSingle(xPos, laneIndex, styleIndex){
    const sty=Styles[styleIndex];
    const sprite=sty.hTile; // one full rotated bottom PNG
    obstacles.push({ type:'H', x:xPos, y:H_LANES[laneIndex], len:sprite.width, thick:sprite.height, styleIndex, sprite, scored:false });
    return sprite.width;
  }
  function pickDistinctStyles(n){
    const chosen=[];
    while(chosen.length<n && Styles.length){
      const idx=Math.floor(Math.random()*Styles.length);
      if(!chosen.includes(idx)) chosen.push(idx);
    }
    while(chosen.length<n) chosen.push(0);
    return chosen;
  }
  function purgeVerticalsInCorridor(x0,x1){
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i]; if(o.type!=='V') continue;
      if((o.x + o.w) > x0 && o.x < x1) obstacles.splice(i,1);
    }
  }
  function randomTrioOrder(){ return [randInt(0,2), randInt(0,2), randInt(0,2)]; }
  function spawnHorizontalTrio(){
    const startAfter = Math.max(xCursor, maxVerticalRightEdge(xCursor)) + BUFFER_PIXELS;
    const [s1,s2,s3]=pickDistinctStyles(3);
    const dynamicGap = Math.max(Math.round(SCROLL_PPS * H_GAP_TIME), H_GAP_MIN);
    const order = randomTrioOrder();

    const x1 = startAfter; const len1 = scheduleHorizontalSingle(x1, order[0], s1);
    const x2 = x1 + len1 + dynamicGap; const len2 = scheduleHorizontalSingle(x2, order[1], s2);
    const x3 = x2 + len2 + dynamicGap; const len3 = scheduleHorizontalSingle(x3, order[2], s3);

    const after = x3 + len3 + BUFFER_PIXELS;
    reservedUntilX = after;
    purgeVerticalsInCorridor(x1, after);

    xCursor = after;
    spawnMode = MODE_VERT;
  }

  function ensureAhead(){
    const aheadTarget = worldScroll + W + AHEAD_LIMIT;
    let guard=0;
    while(xCursor < aheadTarget && guard++ < 100){
      if(spawnMode===MODE_VERT){
        if(xCursor < reservedUntilX) xCursor = reservedUntilX;
        scheduleVertical(xCursor);
        xCursor += VERTICAL_X_GAP;
        verticalCount++;
        if(verticalCount>=10){ verticalCount=0; spawnMode=MODE_HSEG; }
      } else {
        spawnHorizontalTrio();
      }
    }
  }
  function moveWorld(dt){ const dx=SCROLL_PPS*dt; worldScroll+=dx; for(const o of obstacles){ o.x-=dx; } xCursor-=dx; }
  function cleanupObstacles(){ for(let i=obstacles.length-1;i>=0;i--){ const o=obstacles[i]; if((o.type==='V' && o.x+o.w<=0) || (o.type==='H' && o.x+o.len<=0)) obstacles.splice(i,1); } }

  /* HUD + scoring + GOD mode */
  const scoreEl=document.getElementById('scoreVal'), lastEl=document.getElementById('lastVal'), bestEl=document.getElementById('bestVal');
  const lastBadge=document.getElementById('lastBadge'); const godPill=document.getElementById('godPill');
  let score=0, lastScore=0; let best=Number(localStorage.getItem('flappyMoBest')||0); bestEl.textContent=best;

  let godMode=false, godTapCount=0; const GOD_TAPS=10;
  function setGodMode(on){ godMode=!!on; godPill.classList.toggle('hidden', !godMode); }
  lastBadge.addEventListener('click', (e)=>{ e.stopPropagation(); godTapCount++; if(godTapCount>=GOD_TAPS){ setGodMode(!godMode); godTapCount=0; } }, {passive:false});

  function addScore(){
    if(!godMode){
      score++; scoreEl.textContent=score;
      AudioEngine.play('score',0.85);
      if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest',String(best)); }
    }
  }

  function collideAndScore(){
    const bx1=bird.x+BIRD_INSET, bx2=bird.x+bird.w-BIRD_INSET;
    const by1=bird.yRender-(bird.h/2-BIRD_INSET), by2=bird.yRender+(bird.h/2-BIRD_INSET);

    for(const o of obstacles){
      if(o.type==='V'){
        const overlapX=(bx2>o.x)&&(bx1<o.x+o.w);
        if(overlapX){
          const safeTop=o.top-GAP_FORGIVE, safeBottom=o.top+o.gap+GAP_FORGIVE;
          if(by1<safeTop || by2>safeBottom){
            if(!godMode){ AudioEngine.play('hit',0.95); endGame(o.styleIndex); return true; }
          }
        }
        if(!o.scored && (o.x+o.w)<bx1){ o.scored=true; addScore(); }
      } else {
        const rx1=o.x, rx2=o.x+o.len, ry1=o.y-o.thick/2, ry2=o.y+o.thick/2;
        const overlap=(bx2>rx1)&&(bx1<rx2)&&(by2>ry1)&&(by1<ry2);
        if(overlap){ if(!godMode){ AudioEngine.play('hit',0.95); endGame(o.styleIndex); return true; } }
        if(!o.scored && rx2<bx1){ o.scored=true; addScore(); }
      }
    }
    return false;
  }

  /* UI flow */
  const splash=document.getElementById('splash');
  const startBtn=document.getElementById('startBtn');
  const gameOverCard=document.getElementById('gameOverCard');
  const finalScoreP=document.getElementById('finalScoreP');
  const sysImg=document.getElementById('sysImg');
  const sysInfoBox=document.getElementById('sysInfoBox');
  const sysTitle=document.getElementById('sysTitle');
  const sysBlurb=document.getElementById('sysBlurb');
  const sysSpecsBox=document.getElementById('sysSpecsBox');
  const sysSpecs=document.getElementById('sysSpecs');

  let state='title', restartLocked=false;

  function showTitle(){ state='title'; restartLocked=false; splash.classList.remove('hidden'); gameOverCard.classList.add('hidden'); score=0; scoreEl.textContent='0'; bird.reset(); }
  function startGame(){
    if(state==='playing') return;
    state='playing'; restartLocked=false;
    lastScore=score; lastEl.textContent=lastScore; score=0; scoreEl.textContent='0';

    obstacles.length=0; worldScroll=0;
    xCursor=W+FIRST_VERTICAL_LEAD; verticalCount=0; spawnMode=MODE_VERT; reservedUntilX=0;

    ensureAhead();            // seed world
    bird.reset(); splash.classList.add('hidden'); gameOverCard.classList.add('hidden');

    AudioEngine.play('uiStart',0.9);
  }
  function endGame(hitStyleIdx){
    if(state==='gameover') return;
    state='gameover'; bird.v=0;
    finalScoreP.textContent=`Score: ${score} • Best: ${best}`;
    fillSystemPanel(hitStyleIdx);
    gameOverCard.classList.remove('hidden'); gameOverCard.scrollTop=0;
    AudioEngine.play('uiOver',0.9);
    restartLocked=true; setTimeout(()=>{ restartLocked=false; },900);
  }

  function globalPointerStart(e){
    unlockAudio();
    if(e && e.target && e.target.closest('#gameOverCard')) return;
    if(state==='title'){ startGame(); return; }
    if(state==='playing'){ e && e.preventDefault(); bird.flap(); return; }
    if(state==='gameover' && !restartLocked){ startGame(); }
  }
  document.addEventListener('pointerdown', globalPointerStart, {passive:false, capture:true});
  startBtn.addEventListener('click', (e)=>{ unlockAudio(); startGame(); });
  splash.addEventListener('click', (e)=>{ unlockAudio(); if(e.target===startBtn) return; if(state!=='playing') startGame(); }, {passive:true});
  splash.addEventListener('keydown',(e)=>{ if(e.key==='Enter'||e.code==='Space'||e.key===' '){ e.preventDefault(); unlockAudio(); startGame(); }});
  splash.setAttribute('tabindex','0');
  document.addEventListener('keydown',(e)=>{
    if(e.repeat) return;
    if(e.code==='Space'||e.key===' '){
      unlockAudio();
      if(state==='title') startGame();
      else if(state==='gameover'){ if(!restartLocked) startGame(); }
      else bird.flap();
      e.preventDefault();
    }
    if(e.key==='Enter'){ unlockAudio(); if(state==='title') startGame(); else if(state==='gameover' && !restartLocked) startGame(); }
  });

  /* Systems content */
  const SYSTEMS=[
    { title:"EATNASTAK (DOUBLE FACE)", img:"assets/pipe1.png",
      blurb:"When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system offers unmatched flexibility, allowing you to reconfigure it as often as needed to suit your evolving preferences. Whether expanding your collection or rearranging your space, Aetnastak provides the adaptability and reliability you need for efficient and organized library management.",
      specs2:[["Specification","Standard Dimensions"],["Width","24, 30, 36\""],["Depth","7, 8, 9, 10, 11, 12, 13, 14, 15, 16\""],["Height","30, 31, …, 108\""],["Shelf Load Capacity","Up to 50 psf"]] },
    { title:"SMARTSHELF (FIXED, FULL DEPTH)", img:"assets/pipe2.png",
      blurb:"Montel's patented SmartShelf is the most versatile storage shelving system available today. This innovative 4-post shelving offers complete flexibility, accommodating items of all shapes and sizes. It is also designed for easy assembly and reconfiguration.",
      specs2:[["Specification","Standard Dimensions"],["Width","24, 30, 36, 1M, 42, 48, 54\""],["Depth","12, 13, 15, 16, 18, 20, 24, 30, 36\""],["Height","30, 31, …, 120\""],["Frame Load Capacity","Up to 2,500 lbs per frame"],["Shelf Load Capacity","Up to 500 lbs per shelf"]] },
    { title:"4D Wide Span", img:"assets/pipe3.png",
      blurb:"Montel’s 4D Wide Span semi-industrial racking offers the ultimate solution for storing large, heavy items with ease. Engineered for strength and versatility, its robust beams support direct item placement, while optional drop panels transform the structure into sturdy shelving. For enhanced functionality, 4D frames seamlessly integrate with SmartShelf 4-Post accessories, delivering unmatched adaptability to meet your storage needs.",
      specs2:[["Specification","Capacity"],["Load per Bay","Up to 5,000 lbs per bay (2 268 kg)"],["Load per Level","3\" Beam : 1,000 lbs per pair of beam (454 kg)"],["Span","4\" Beam : 1,500 lbs per pair of beam (680 kg)"],["Height","4' to 8' (1.2 m to 2.4 m)"],["Depth","Up to 20' (6.1 m)"]] },
    { title:"SmartSpace", img:"assets/pipe4.png",
      blurb:"Montel’s SmartSpace storage system offers a cost-effective and versatile solution for organizing light objects. Designed with efficiency in mind, the SmartSpace system ensures quick and hassle-free installation, helping you save time and reduce expenses. Choose between two tailored options, manual or mechanically assisted, to meet your unique storage requirements with ease and precision.",
      specs2:[["Specification","Capacity"],["Section Load Capacity","2,000 lbs per section (907 kg)"],["Section Length","24\" to 48\" (0.61m - 1.2m)"],["Section Depth","Panels: 12\" to 48\" / Columns: 18\" to 48\""],["Carriage Load Capacity","16,000 lbs per carriage (7270kg)"],["Carriage Length","Max 24' (7.3 m)"]] },
    { title:"SmartGlide", img:"assets/pipe5.png",
      blurb:"Montel’s SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system that leverages your available space to maximize storage efficiency. It’s an excellent alternative when space limitations prevent you from using one of our larger mobile systems. APPLICATION: Unlike other mobile systems, you do not have to open up an aisle to access your stored material. Just slide the system laterally to reach what you need. This allows you to make full use of your storage space without wasting a square inch. For high-density storage of relatively small and light items in tight quarters, such as files, boxes, medications, and parts, it's vastly superior to conventional filing and storage systems.",
      specs2:null },
    { title:"GREENRAK", img:"assets/greenrak.png",
      blurb:"Montel’s GREENRAK® 2.0 mobile system has been developed specifically for growing applications. Its lightweight, rust-resistant, and simple design allows for easy installation, use, and maintenance.",
      specs3:{ headers:["Specification","Section","Mobile"], rows:[["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],["Depth","—","36”, 42”, 48”"],["Length","4’, 8’","Max 50’"]] } },
    { title:"Mobilex", img:"assets/pipe7.png",
      blurb:"Montel's Mobilex mechanical-assist mobile storage systems provide your organization with the flexibility to customize high-density storage solutions to meet your unique needs. Its innovative mechanism allows for effortless access and mobilization of your items.",
      specs2:[["Specification","Capacity"],["Load Capacity","1,000 lbs per linear foot (1 488kg/m)"],["Depth","3' to 45' (0.91m - 13.7m)"],["Length","15\" to 48\" (0.4m -2.4 m)"]] },
    { title:"SAFERAK 32P & 60P", img:"assets/pipe8.png",
      blurb:"Unlock the full potential of your storage with Montel’s cutting-edge powered mobile racking system. Designed for industrial environments, the SAFERAK® 32P & 60P can handle, respectively, an impressive load capacity of 32,000 lbs and 60,000 lbs per double rack section, optimizing storage efficiency and cutting costs. Embrace the future with smart factory technology, fully equipped for Industry 4.0 to boost your production efficiency and adaptability through seamless digital transformation.",
      specs3:{ headers:["Specification","SAFERAK 32P","SAFERAK 60P"], rows:[
        ["Load per Double-Bay","32,000lbs (14 500 kg)","60,000lbs (27 200 kg)"],
        ["Load per Carriage","256,000 lbs (116 000 kg)","480,000 lbs (217 600 kg)"],
        ["Bay Depth","Up to 8' (2.4 m)","Up to 8' (2.4 m)"],
        ["Bay Width","Up to 12' (3.6 m)","Up to 12' (3.6 m)"],
        ["Carriage Length","Up to 100’ (30 m)","Up to 120’ (36 m)"],
        ["Industrial Safeties","YES","YES"],
        ["PLC","YES","YES"],
        ["Touchscreen UI","YES","YES"],
        ["Signal Strobe and Buzzers","YES","YES"],
        ["VPN eWon Connectivity","YES","YES"],
        ["Rear Controls","Optional","Optional"],
        ["In-Aisle E-Stops","Optional","Optional"],
        ["Illuminated E-Stops","Optional","Optional"]
      ] } }
  ];
  function fillSystemPanel(i){
    const sysImg=document.getElementById('sysImg');
    const sysInfoBox=document.getElementById('sysInfoBox');
    const sysTitle=document.getElementById('sysTitle');
    const sysBlurb=document.getElementById('sysBlurb');
    const sysSpecsBox=document.getElementById('sysSpecsBox');
    const sysSpecs=document.getElementById('sysSpecs');

    if(typeof i==='number' && SYSTEMS[i]){
      const info=SYSTEMS[i];
      sysTitle.textContent=info.title||`System ${i+1}`;
      sysBlurb.textContent=info.blurb||'';
      if(info.img){ sysImg.style.opacity='0'; sysImg.onload=()=>sysImg.style.opacity='1'; sysImg.src=info.img; sysImg.style.display='block'; } else sysImg.style.display='none';
      sysSpecs.innerHTML='';
      if(info.specs3 && info.specs3.headers && info.specs3.rows){
        const h=info.specs3.headers; sysSpecs.innerHTML='<thead><tr>'+h.map(x=>`<th>${x}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tb=sysSpecs.querySelector('tbody'); info.specs3.rows.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=r.map((c,k)=>`<td${k===0?' style="font-weight:600"':''}>${c}</td>`).join(''); tb.appendChild(tr); });
        sysSpecsBox.style.display='block';
      } else if(info.specs2){
        const [hdr,...rows]=info.specs2; sysSpecs.innerHTML='<thead><tr>'+hdr.map(x=>`<th>${x}</th>`).join('')+'</tr></thead><tbody></tbody>';
        const tb=sysSpecs.querySelector('tbody'); rows.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td style="font-weight:600">${r[0]}</td><td>${r[1]}</td>`; tb.appendChild(tr); });
        sysSpecsBox.style.display='block';
      } else { sysSpecsBox.style.display='none'; }
      sysInfoBox.style.display='block';
    } else { sysInfoBox.style.display='none'; sysImg.style.display='none'; }
  }

  /* Main loop with render interpolation */
  function loop(ts){
    let frameDt=(ts-lastTs)/1000; if(frameDt>MAX_FRAME_DT)frameDt=MAX_FRAME_DT; if(frameDt<0)frameDt=0; lastTs=ts;
    accumulator+=frameDt;

    while(accumulator>=STEP){
      if(state==='playing'){
        bird.yPrev = bird.y; bird.vPrev = bird.v;
        bird.v+=G*STEP; if(bird.v>MAX_FALL) bird.v=MAX_FALL; bird.y+=bird.v*STEP;

        const topWrap=-bird.h*TOP_OVERLAP_FRAC, bottomWrap=H+bird.h*BOTTOM_OVERLAP_FRAC;
        if(bird.y<topWrap){ const over=topWrap-bird.y; bird.y=bottomWrap-over; bird.yPrev=bird.y; }
        else if(bird.y>bottomWrap){ const over=bird.y-bottomWrap; bird.y=topWrap+over; bird.yPrev=bird.y; }

        moveWorld(STEP); ensureAhead(); cleanupObstacles();
        bird.animTime+=STEP;
      }
      accumulator-=STEP;
    }

    const alpha = (state==='playing') ? Math.min(1, accumulator/STEP) : 0;
    const dxInterp = (state==='playing') ? (SCROLL_PPS * alpha * STEP) : 0;

    ctx.clearRect(0,0,W,H); drawBackground();

    bird.yRender = bird.yPrev + (bird.y - bird.yPrev) * alpha;
    const vRender = bird.vPrev + (bird.v - bird.vPrev) * alpha;

    for(const o of obstacles){
      const drawX = o.x - dxInterp;
      if(o.type==='V'){ if(o.sprite) ctx.drawImage(o.sprite, drawX, 0, o.w, H); }
      else { ctx.drawImage(o.sprite, drawX, o.y - o.thick/2); }
    }

    bird.draw(vRender);
    if(state!=='title') drawVersionTag();
    if(state==='playing') collideAndScore();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  /* Boot assets & enter title */
  (async ()=>{
    try{
      const [sprite,fallback,bg,...rest]=await Promise.all([
        loadImageWithTimeout("assets/bird-sprite.png"),
        loadImageWithTimeout("assets/bird.png"),
        loadImageWithTimeout("assets/bg.png"),
        ...PIPE_STYLES_CFG.flatMap(s=>[loadImageWithTimeout(s.bottom.url), loadImageWithTimeout(s.top.url)])
      ]);
      birdSprite=sprite||null; birdFallbackImg=(!birdSprite && fallback)?fallback:null; bgImg=bg||null;

      const bottoms=[], tops=[];
      for(let i=0;i<PIPE_STYLES_CFG.length;i++){ bottoms[i]=rest[i*2]||null; tops[i]=rest[i*2+1]||null; }
      Raw.bottoms=bottoms; Raw.tops=tops;

      Styles.length=0;
      for(let i=0;i<PIPE_STYLES_CFG.length;i++){
        const cfg=PIPE_STYLES_CFG[i];
        const bot=Raw.bottoms[i], top=Raw.tops[i];
        const drawW=Math.round(PIPE_W*(cfg.scale||1));

        const bottomSet=buildCapBodyPx(bot,drawW,cfg.bottom.capPx,cfg.bottom.capFrom);
        const topSet=buildCapBodyPx(top,drawW,cfg.top.capPx,cfg.top.capFrom);

        // Horizontal: whole bottom PNG, rotated 90° left, thickness = drawW
        let hTile;
        if(bot && bot.naturalWidth){
          const base=makeScaledCanvas(bot, drawW, Math.round(bot.naturalHeight*(drawW/bot.naturalWidth)));
          const rotated=rotateLeftCanvas(base);
          hTile=scaleCanvasToHeight(rotated, drawW);
        } else {
          hTile=makeScaledCanvas(null, drawW, drawW);
        }

        Styles.push({ name:cfg.name, bottom:bottomSet, top:topSet, drawW, hTile });
      }
      if(!Styles.length){
        const drawW=PIPE_W, ph=makeScaledCanvas(null,drawW,120);
        Styles.push({ name:'PH', bottom:{cap:ph,body:ph}, top:{cap:ph,body:ph}, drawW, hTile:makeScaledCanvas(null,drawW,drawW) });
      }
    }catch(e){ console.error(e); }
    showTitle(); // enter start screen
  })();

  addEventListener('error', ()=>{ try{ document.getElementById('splash').classList.remove('hidden'); }catch(_){} }, {capture:true});

})();
</script>
</body>
</html>
