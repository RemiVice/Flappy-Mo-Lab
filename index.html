<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Flappy Mo ‚Äî Local Assets (v1.46)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">
<style>
  :root{ --glass:rgba(20,24,28,.80); --bg:#0b0d10; }
  * { box-sizing: border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); overflow:hidden; }
  body{ font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color:transparent; }

  /* Canvas always centered; JS resizes scale() */
  #game{
    position:fixed; top:50%; left:50%;
    width:1920px; height:1080px;
    transform:translate(-50%, -50%) scale(1);
    transform-origin:center center;
    background:#000; touch-action:none; image-rendering:auto;
    border-radius:14px; border:1px solid rgba(255,255,255,.08);
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; z-index:10; padding:16px; }
  .card{
    pointer-events:auto; color:#fff; background:var(--glass);
    border:1px solid rgba(255,255,255,.08); border-radius:14px;
    padding:20px 22px; text-align:center; backdrop-filter:blur(6px);
    box-shadow:0 10px 30px rgba(0,0,0,.5);
    max-width:min(92vw,560px); max-height:calc(100vh - 64px);
    overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y;
    scroll-behavior:smooth; cursor:pointer;
  }
  .card h1{ margin:0 0 8px; font-size:clamp(20px,4vw,34px); font-weight:800 }
  .card p{ margin:0; font-size:clamp(13px,3.2vw,16px) }
  .hidden{ display:none }

  .hud{ position:fixed; top:10px; left:50%; transform:translateX(-50%); display:flex; gap:12px; pointer-events:none; z-index:12 }
  .badge{ background:var(--glass); border-radius:10px; padding:4px 10px; color:#fff; font-weight:700; font-size:14px; min-width:84px; text-align:center; border:1px solid rgba(255,255,255,.1) }

  .rot-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.78); color:#fff; display:none; align-items:center; justify-content:center; text-align:center; z-index:999 }
  .rot-overlay.show{ display:flex }
  .rot-box{ max-width:90vw; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:22px; background:rgba(20,24,28,.85) }

  .mute-btn, .fs-btn{ position:fixed; z-index:13; pointer-events:auto; background:var(--glass); color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; font-size:12px; font-weight:700; cursor:pointer; }
  .mute-btn{ right:12px; top:12px; }
  .fs-btn{ right:12px; bottom:12px; }

  #iosFsHint{ position:fixed; right:12px; bottom:12px; z-index:12; color:#fff; font-size:12px; background:var(--glass); border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:6px 10px; display:none; }

  #sysImg { max-width:100%; max-height:240px; object-fit:contain; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:10px; margin:10px 0; display:none; opacity:0; transition:opacity .25s ease; }
  #sysSpecs th, #sysSpecs td{ border-bottom:1px solid rgba(255,255,255,.12); padding:6px; text-align:left; }
  #sysSpecs th{ font-weight:800; }
  #sysSpecs td:first-child{ font-weight:600; }

  /* Loading overlay */
  #loadingOverlay{
    position:fixed; inset:0; display:grid; place-items:center;
    background:#0b0d10; color:#fff; z-index:2000;
    font-weight:800; font-size:18px; letter-spacing:.3px;
  }
  #loadingBox{
    background:rgba(20,24,28,.85); border:1px solid rgba(255,255,255,.12);
    border-radius:14px; padding:16px 20px; box-shadow:0 10px 30px rgba(0,0,0,.5);
  }
</style>
</head>
<body>

<canvas id="game" width="1920" height="1080"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge">Score: <span id="scoreVal">0</span></div>
  <div class="badge">Last:  <span id="lastVal">0</span></div>
  <div class="badge">Best:  <span id="bestVal">0</span></div>
</div>
<button id="muteBtn" class="mute-btn" aria-pressed="false" title="Toggle sound">üîä Sound</button>
<button id="fsBtn" class="fs-btn" title="Fullscreen">‚õ∂ Fullscreen</button>
<div id="iosFsHint">Tip: On iPhone, use ‚ÄúAdd to Home Screen‚Äù for true fullscreen.</div>

<!-- Overlays -->
<div class="overlay">
  <div id="startCard" class="card" role="button" aria-label="Start game">
    <h1 id="startTitle">Tap to Start</h1>
    <p id="startSub">Tap again to flap ‚Ä¢ Best is saved ‚Ä¢ <b>v<span id="verLabel">1.46</span></b></p>
    <p id="fsHint" style="margin-top:10px; font-size:13px; opacity:.95; display:none; color:#ff4d4f">üí° Tip: For the best experience, use the ‚õ∂ Fullscreen button.</p>
  </div>

  <div id="gameOverCard" class="card hidden" style="align-self:flex-start; margin-top:20px;">
    <h1>Game Over</h1>
    <p id="finalScoreP">Score: 0 ‚Ä¢ Best: 0</p>
    <p id="fsHintOver" style="margin-top:10px; font-size:13px; opacity:.95; display:none; color:#ff4d4f">üí° Tip: For the best experience, use the ‚õ∂ Fullscreen button.</p>
    <p style="opacity:.85;font-size:12px;margin-top:8px">Tap <b>outside</b> this window to restart (after 1s)</p>

    <img id="sysImg" alt="System image" />
    <div id="sysInfoBox" style="margin-top:12px; text-align:left; display:none">
      <div style="font-weight:800; font-size:16px; margin-bottom:6px">System: <span id="sysTitle">‚Äî</span></div>
      <div id="sysBlurb" style="opacity:.9; font-size:13px; margin-bottom:8px">‚Äî</div>
      <div id="sysSpecsBox" style="margin-top:10px; display:none">
        <table id="sysSpecs" style="width:100%; border-collapse:collapse; font-size:13px"></table>
      </div>
      <div id="sysLinks" style="margin-top:8px; font-size:13px"></div>
    </div>
  </div>
</div>

<!-- Landscape-only blocker -->
<div id="rotBlock" class="rot-overlay">
  <div class="rot-box">
    <h2>Rotate your device</h2>
    <p>This game is landscape-only. Turn your device to play.</p>
  </div>
</div>

<!-- Loading overlay (prevents first-frame flash) -->
<div id="loadingOverlay"><div id="loadingBox">Loading‚Ä¶</div></div>

<script>
(function () {
  const VERSION = '1.46';
  const ua = navigator.userAgent;
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(ua);
  const isiOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

  // World (logic) size ‚Äî never changes
  const WORLD_W = 1920, WORLD_H = 1080;

  // Mobile performance: render at lower backbuffer, scale up
  let backW = WORLD_W, backH = WORLD_H;
  if (isMobile) { backW = 1280; backH = 720; }  // perf boost on phones

  const SPEED_MULT = isMobile ? 1.40 : 1.50;

  const G_PPS2         = 4800 * SPEED_MULT;       // gravity
  const LIFT_V0        = -1350 * SPEED_MULT;      // flap velocity
  const MAX_FALL_PPS   = 2200 * SPEED_MULT;       // terminal
  const PIPE_SPEED_PPS = 480  * SPEED_MULT;       // scroll speed
  const PIPE_W         = 180;
  const GAP_MIN        = 310, GAP_MAX = 450;
  const PIPE_SPAWN_EVERY_S = 1.8;

  const BIRD_INSET = 8;

  // Test: first obstacle is a single horizontal bar made from the BOTTOM pipe rotated left
  const TEST_FIRST_HORIZONTAL = true;
  let spawnedHorizontalTest = false;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.imageSmoothingEnabled = true;

  function applyBackbuffer(){
    canvas.width = backW;
    canvas.height = backH;
    ctx.setTransform(backW / WORLD_W, 0, 0, backH / WORLD_H, 0, 0);
  }
  applyBackbuffer();

  document.getElementById('verLabel').textContent = VERSION;

  /* ===== Fit & Orientation (CSS scale only) ===== */
  function fitCanvas() {
    const vw = window.innerWidth;
    const vh = Math.round(window.visualViewport ? window.visualViewport.height : window.innerHeight);
    const scale = Math.min(vw / WORLD_W, vh / WORLD_H);
    canvas.style.transform = `translate(-50%, -50%) scale(${scale})`;
  }
  function safeFit() {
    window.scrollTo(0,0);
    fitCanvas();
    requestAnimationFrame(fitCanvas);
    setTimeout(fitCanvas, 250);
    setTimeout(fitCanvas, 600);
  }
  const rotBlock = document.getElementById('rotBlock');
  let landscapeOK = true;
  function checkOrientation(){
    const isLandscape = window.innerWidth >= window.innerHeight;
    landscapeOK = isLandscape;
    rotBlock.classList.toggle('show', !isLandscape);
    safeFit();
  }
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', checkOrientation);

  /* ===== HUD + overlays ===== */
  const scoreEl = document.getElementById('scoreVal');
  const lastEl  = document.getElementById('lastVal');
  const bestEl  = document.getElementById('bestVal');
  const startCard   = document.getElementById('startCard');
  const gameOverCard= document.getElementById('gameOverCard');
  const finalScoreP = document.getElementById('finalScoreP');
  const fsBtn = document.getElementById('fsBtn');
  const fsHintStart= document.getElementById('fsHint');
  const fsHintOver = document.getElementById('fsHintOver');
  const iosFsHint = document.getElementById('iosFsHint');

  function fsEnabled(){
    return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled);
  }
  function inFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
  function updateFsBtn(){
    const full = !!inFullscreen();
    fsBtn.textContent = full ? "‚§¢ Exit" : "‚õ∂ Fullscreen";
    fsBtn.title = full ? "Exit fullscreen" : "Enter fullscreen";
    fsHintStart.style.display = (full || !fsEnabled()) ? 'none' : 'block';
    fsHintOver.style.display  = (full || !fsEnabled()) ? 'none' : 'block';
  }
  if (!fsEnabled() || (isiOS && !document.documentElement.requestFullscreen)) {
    fsBtn.style.display = 'none';
    iosFsHint.style.display = 'block';
  } else {
    iosFsHint.style.display = 'none';
  }
  fsBtn.addEventListener('click', async (e)=>{
    e.stopPropagation();
    const el = document.documentElement;
    try{
      if(!inFullscreen()){
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
        else if (el.msRequestFullscreen) await el.msRequestFullscreen();
      } else {
        if (document.exitFullscreen) await document.exitFullscreen();
        else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
        else if (document.msExitFullscreen) await document.msExitFullscreen();
      }
    }catch(_){}
    updateFsBtn();
  }, {passive:false});
  ["fullscreenchange","webkitfullscreenchange","msfullscreenchange"].forEach(ev=>document.addEventListener(ev, updateFsBtn, {passive:true}));

  /* ===== Game state ===== */
  let started=false, over=false, restartLocked=false;
  let score=0, lastScore=0, best=Number(localStorage.getItem('flappyMoBest')||0);
  bestEl.textContent = best;
  let spawnTimer = 0;

  /* ===== Audio ===== */
  let audioCtx = null, masterGain = null;
  let muted = false, audioReady = false;
  function setMuted(m){ muted = m; if (masterGain) masterGain.gain.value = muted ? 0 : 1;
    const btn = document.getElementById('muteBtn'); btn.textContent = muted ? "üîá Muted" : "üîä Sound"; btn.setAttribute("aria-pressed", String(muted)); }
  document.getElementById('muteBtn').addEventListener('click', (e)=>{ e.stopPropagation(); setMuted(!muted); });
  async function initAudioOnce(){
    if (audioReady) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:"interactive" });
    masterGain = audioCtx.createGain(); masterGain.gain.value = muted ? 0 : 0.8; masterGain.connect(audioCtx.destination);
    try { await audioCtx.resume(); } catch(e){}
    audioReady = true;
  }
  function envGain(duration=0.25, attack=0.005, volume=1){
    const g = audioCtx.createGain(); const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(volume, now + attack); g.gain.exponentialRampToValueAtTime(0.0001, now + duration); return g;
  }
  function woosh(dur=0.25){
    if(!audioReady || muted) return;
    const bufferSize = Math.max(1, audioCtx.sampleRate * dur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2 - 1) * 0.3;
    const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter(); filter.type = "lowpass"; filter.frequency.value = 1200;
    const g = envGain(dur, 0.01, 0.4);
    noise.connect(filter); filter.connect(g); g.connect(masterGain);
    noise.start(); noise.stop(audioCtx.currentTime + dur + 0.05);
  }
  function oceanWave(dur=1.6){
    if(!audioReady || muted) return;
    const bufferSize = Math.max(1, audioCtx.sampleRate * dur);
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    let b0=0, b1=0, b2=0;
    for (let i=0;i<bufferSize;i++){ const white = Math.random()*2 - 1;
      b0 = 0.997*b0 + white*0.030; b1 = 0.985*b1 + white*0.045; b2 = 0.950*b2 + white*0.070;
      data[i] = (b0+b1+b2)*0.6; }
    const src = audioCtx.createBufferSource(); src.buffer = buffer;
    const lp = audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value = 800;
    const lfo = audioCtx.createOscillator(); lfo.type="sine"; lfo.frequency.value = 0.25;
    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 220;
    lfo.connect(lfoGain); lfoGain.connect(lp.frequency);
    const g = audioCtx.createGain(); const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0, now); g.gain.linearRampToValueAtTime(0.35, now + 0.18); g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    src.connect(lp); lp.connect(g); g.connect(masterGain);
    src.start(); lfo.start(); const stopAt = now + dur + 0.05; src.stop(stopAt); lfo.stop(stopAt);
  }
  const playFlap = () => woosh(0.25);
  const playHit  = () => oceanWave(1.6);

  function loadImageWithTimeout(src, timeoutMs=6000){
    return new Promise((resolve) => {
      if(!src){ resolve(null); return; }
      const img = new Image(); img.referrerPolicy = 'no-referrer';
      let done = false;
      const finish = (val)=>{ if(done) return; done = true; resolve(val || null); };
      const timer = setTimeout(()=>finish(null), timeoutMs);
      img.onload = ()=>{ clearTimeout(timer); finish(img); };
      img.onerror = ()=>{ clearTimeout(timer); finish(null); };
      img.src = src;
    });
  }

  /* ===== Procedural fallbacks ===== */
  function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
  function buildFallbackBG(){
    const c = makeCanvas(1920,1080); const g = c.getContext('2d');
    const grad = g.createLinearGradient(0,0,0,1080);
    grad.addColorStop(0,'#7ed0ff'); grad.addColorStop(1,'#d9f4ff');
    g.fillStyle = grad; g.fillRect(0,0,1920,1080);
    g.globalAlpha=0.35; g.fillStyle='#fff'; g.beginPath(); g.arc(1600,220,160,0,Math.PI*2); g.fill(); g.globalAlpha=1;
    return c;
  }
  function buildFallbackBird(){
    const c = makeCanvas(256,256); const g = c.getContext('2d'); g.translate(128,128);
    const bodyGrad = g.createRadialGradient(0,-20,20,0,0,120);
    bodyGrad.addColorStop(0,'#ffec77'); bodyGrad.addColorStop(1,'#f5b91a');
    g.fillStyle = bodyGrad; g.beginPath(); g.arc(0,0,90,0,Math.PI*2); g.fill();
    g.fillStyle='rgba(255,255,255,0.65)'; g.beginPath(); g.ellipse(-20,10,35,25,-0.4,0,Math.PI*2); g.fill();
    g.fillStyle='#fff'; g.beginPath(); g.arc(30,-20,16,0,Math.PI*2); g.fill();
    g.fillStyle='#222'; g.beginPath(); g.arc(34,-18,7,0,Math.PI*2); g.fill();
    g.fillStyle='#ff7f2a'; g.beginPath(); g.moveTo(90,-6); g.lineTo(130,10); g.lineTo(90,26); g.closePath(); g.fill();
    return c;
  }

  /* ===== Pipe asset builders ===== */
  function makeScaledCanvas(img,w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d"); g.imageSmoothingEnabled=true; if(img) g.drawImage(img,0,0,w,h); else { g.fillStyle="#3a3a3a"; g.fillRect(0,0,w,h);} return c; }
  function buildCapBodyPx(img, drawW, capPxSrc, capFrom="top"){
    if(!img){ const ph=document.createElement("canvas"); ph.width=drawW; ph.height=120; const g=ph.getContext("2d"); g.fillStyle="#2e8b57"; g.fillRect(0,0,drawW,120); return { cap:ph, body:ph }; }
    const scale = drawW / (img.naturalWidth || img.width);
    const scaledH = Math.max(1, Math.round((img.naturalHeight || img.height) * scale));
    const capH    = Math.max(1, Math.round(capPxSrc * scale));
    const full = makeScaledCanvas(img, drawW, scaledH);
    const cap  = document.createElement("canvas");
    const body = document.createElement("canvas");
    cap.width = drawW; cap.height = Math.min(capH, scaledH);
    body.width = drawW; body.height = Math.max(1, scaledH - cap.height);
    const cg = cap.getContext("2d"), bg = body.getContext("2d");
    cg.imageSmoothingEnabled = bg.imageSmoothingEnabled = true;
    if (capFrom === "top") {
      cg.drawImage(full, 0, 0, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, cap.height, drawW, body.height, 0, 0, drawW, body.height);
    } else {
      cg.drawImage(full, 0, scaledH - cap.height, drawW, cap.height, 0, 0, drawW, cap.height);
      bg.drawImage(full, 0, 0, drawW, body.height, 0, 0, drawW, body.height);
    }
    return { cap, body };
  }
  function rotateCCW90(src){
    const c = document.createElement('canvas');
    c.width = src.height; c.height = src.width;
    const g = c.getContext('2d');
    g.imageSmoothingEnabled = true;
    g.translate(0, c.height);
    g.rotate(-Math.PI/2);
    g.drawImage(src, 0, 0);
    return c;
  }

  const Raw={ bottoms:[], tops:[] };
  const Styles=[];

  function rebuildStyles(){
    Styles.length=0;
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      const cfg=PIPE_STYLES_CFG[i];
      const bot=Raw.bottoms[i], top=Raw.tops[i];
      const drawW = Math.round(PIPE_W * (cfg.scale || 1));
      const bottom = buildCapBodyPx(bot, drawW, cfg.bottom.capPx, cfg.bottom.capFrom);
      const topset = buildCapBodyPx(top, drawW, cfg.top.capPx,   cfg.top.capFrom);

      // Build horizontal (left-facing) assets from BOTTOM parts
      const hcap  = rotateCCW90(bottom.cap);   // front (former top) now faces LEFT
      const hbody = rotateCCW90(bottom.body);  // tiling along X

      Styles.push({ name:cfg.name, drawW,
        bottom, top:topset,
        hbar:{ cap:hcap, body:hbody, thickness:drawW }
      });
    }
  }

  /* ===== Obstacles: vertical pipes + horizontal bar ===== */
  const obstacles = []; // {type:'vpipe'|'hbar', ...}
  let lastSpawnedAtX = WORLD_W;

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function spawnVPipe(){
    if(!Styles.length) return;
    const margin = Math.round(WORLD_H * 0.10);
    const maxSection = Math.round(WORLD_H * 0.45);
    const minGapRequired = WORLD_H - 2*maxSection - 2*margin;
    const minGap = Math.max(GAP_MIN, Math.min(GAP_MAX, Math.max(0, Math.floor(minGapRequired))));
    const gap = randInt(minGap, GAP_MAX);

    let top = randInt(margin, WORLD_H - gap - margin);
    if (top > maxSection) top = maxSection;
    let bottomH = WORLD_H - (top + gap);
    if (bottomH > maxSection) top = WORLD_H - gap - maxSection;
    top = Math.max(margin, Math.min(top, WORLD_H - gap - margin));

    const styleIndex = Math.floor(Math.random()*Styles.length);
    const sty = Styles[styleIndex];
    const obj = { type:'vpipe', x:WORLD_W, prevX:WORLD_W, top, gap, w:sty.drawW, styleIndex, scored:false };
    obstacles.push(obj);
    lastSpawnedAtX = obj.x;
  }

  // Single horizontal bar (using rotated bottom pipe), with left cap and body tiling to the right
  function spawnHBar(){
    const styleIndex = Math.floor(Math.random()*Styles.length);
    const sty = Styles[styleIndex];

    const length = Math.round(WORLD_W * 0.68);      // bar length along X
    const marginY = Math.round(WORLD_H * 0.15);
    const yTop = randInt(marginY, WORLD_H - marginY - sty.hbar.thickness);

    const obj = {
      type:'hbar',
      x: WORLD_W, prevX: WORLD_W,
      y: yTop, // top of bar
      length,
      styleIndex,
      thickness: sty.hbar.thickness,
      scored:false
    };
    obstacles.push(obj);
    lastSpawnedAtX = obj.x;
  }

  function spawnObstacle(){
    if (TEST_FIRST_HORIZONTAL && !spawnedHorizontalTest){
      spawnedHorizontalTest = true;
      spawnHBar();
      // give extra time before next spawn to avoid overlap during test
      spawnTimer = -0.5;
      return;
    }
    spawnVPipe();
  }

  function physicsStep(dt){
    spawnTimer += dt * SPEED_MULT;
    while (spawnTimer >= PIPE_SPAWN_EVERY_S) {
      spawnObstacle();
      spawnTimer -= PIPE_SPAWN_EVERY_S;
    }

    for(const o of obstacles){ o.x -= PIPE_SPEED_PPS * dt; }

    bird.step(dt);

    // Floor/ceiling
    if(bird.y + (bird.h - BIRD_INSET) >= WORLD_H){ endGame(null); }
    if(bird.y + BIRD_INSET <= 0){ endGame(null); }

    // Bird AABB
    const bx1 = bird.x + BIRD_INSET;
    const bx2 = bird.x + bird.w - BIRD_INSET;
    const by1 = bird.y + BIRD_INSET;
    const by2 = bird.y + bird.h - BIRD_INSET;

    for(const o of obstacles){
      if (o.type === 'vpipe'){
        const overlapX = (bx2 > o.x) && (bx1 < o.x + o.w);
        if (overlapX) {
          const safeTop = o.top;
          const safeBottom = o.top + o.gap;
          const hitsTop = by1 < safeTop;
          const hitsBottom = by2 > safeBottom;
          if (hitsTop || hitsBottom) { endGame(o.styleIndex); break; }
        }
        if(!o.scored && (o.x+o.w) < bx1){
          o.scored = true; score++; scoreEl.textContent = score;
          if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest', String(best)); }
        }
      } else if (o.type === 'hbar'){
        // Horizontal collision ONLY: collide if bird overlaps the bar rectangle
        const right = o.x + o.length;
        const overlapX = (bx2 > o.x) && (bx1 < right);
        const overlapY = (by2 > o.y) && (by1 < o.y + o.thickness);
        if (overlapX && overlapY){ endGame(o.styleIndex); break; }

        if(!o.scored && right < bx1){
          o.scored = true; score++; scoreEl.textContent = score;
          if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('flappyMoBest', String(best)); }
        }
      }
    }

    // Remove offscreen
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      const ext = (o.type==='vpipe') ? o.w : o.length;
      if (o.x + ext <= 0) obstacles.splice(i,1);
    }
  }

  function drawBackground(){
    if(bgImg) ctx.drawImage(bgImg,0,0,WORLD_W,WORLD_H);
    else { ctx.fillStyle="#1e1e1e"; ctx.fillRect(0,0,WORLD_W,WORLD_H); }
  }

  function drawVPipes(alpha){
    obstacles.forEach(o=>{
      if (o.type !== 'vpipe') return;
      const sty = Styles[o.styleIndex]; if(!sty) return;
      const w = o.w;

      const interpX = o.prevX + (o.x - o.prevX) * alpha;
      const renderX = Math.round(interpX);

      // top
      const topH = o.top;
      if(topH>0){
        const cap = sty.top.cap, body = sty.top.body;
        const capH = Math.min(cap.height, topH), bodyH = topH - capH;
        if(bodyH>0) drawBodyTiled(renderX, 0, bodyH, body, "topUp", w);
        ctx.drawImage(cap, renderX, topH - capH, w, capH);
      }

      // bottom
      const by = o.top + o.gap;
      const bottomH = WORLD_H - by;
      if(bottomH>0){
        const cap = sty.bottom.cap, body = sty.bottom.body;
        const capH = Math.min(cap.height, bottomH);
        ctx.drawImage(cap, renderX, by, w, capH);
        const remain = bottomH - capH;
        if(remain>0) drawBodyTiled(renderX, by + capH, remain, body, "bottomDown", w);
      }
    });
  }

  // Tile a vertical body canvas along Y (existing), and a horizontal body along X (new)
  function drawBodyTiled(x,yStart,totalH,tile,mode,w){
    const th=tile.height; if(totalH<=0||th<=0) return;
    if(mode==="topUp"){
      let y=totalH-th;
      while(y>=0){ ctx.drawImage(tile,x,y,w,th); y-=th; }
      const rem=totalH%th; if(rem>0) ctx.drawImage(tile,0,th-rem,tile.width,rem,x,0,w,rem);
    } else {
      let y=yStart, end=yStart+totalH;
      while(y+th<=end){ ctx.drawImage(tile,x,y,w,th); y+=th; }
      const left=end-y; if(left>0) ctx.drawImage(tile,0,0,tile.width,left,x,y,w,left);
    }
  }
  function drawBodyTiledX(xStart,y,totalW,tile,h){
    const tw=tile.width; if(totalW<=0||tw<=0) return;
    let x=xStart, end=xStart+totalW;
    while(x+tw<=end){ ctx.drawImage(tile,x,y,tw,h); x+=tw; }
    const left=end-x; if(left>0) ctx.drawImage(tile,0,0,left,tile.height,x,y,left,h);
  }

  function drawHBar(alpha){
    obstacles.forEach(o=>{
      if (o.type !== 'hbar') return;
      const sty = Styles[o.styleIndex]; if(!sty) return;
      const H = sty.hbar.thickness;

      const interpX = o.prevX + (o.x - o.prevX) * alpha;
      const renderX = Math.round(interpX);

      // Left-facing cap (rotated bottom cap)
      const cap = sty.hbar.cap;
      const body = sty.hbar.body;

      const capW = cap.width; // extends into the bar along +X
      const capH = H;

      // Cap
      ctx.drawImage(cap, renderX, o.y, capW, capH);

      // Body tiles to the right
      const remain = o.length - capW;
      if (remain > 0){
        drawBodyTiledX(renderX + capW, o.y, remain, body, H);
      }
    });
  }

  // Styles + assets config
  const PIPE_STYLES_CFG = [
    { name:"Pipe 1", bottom:{url:"assets/pipe1-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe1-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 2", bottom:{url:"assets/pipe2-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe2-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 3", bottom:{url:"assets/pipe3-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe3-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 4", bottom:{url:"assets/pipe4-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe4-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 5", bottom:{url:"assets/pipe5-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe5-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 6", bottom:{url:"assets/pipe6-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe6-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 7", bottom:{url:"assets/pipe7-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe7-top.png", capPx:64, capFrom:"bottom"} },
    { name:"Pipe 8", bottom:{url:"assets/pipe8-bottom.png", capPx:64, capFrom:"top"},    top:{url:"assets/pipe8-top.png", capPx:64, capFrom:"bottom"}, scale:1.4 }
  ];

  const SYSTEMS = [
    { title: "EATNASTAK (DOUBLE FACE)", blurb: "When it comes to library storage solutions, Aetnastak is the industry standard. This innovative compact cantilever shelving system offers unmatched flexibility...", img: "assets/pipe1.png", tds: "#",
      specs: [["Width","24, 30, 36\""],["Depth","7‚Äì16\""],["Height","30\" to 108\""],["Shelf Load Capacity","Up to 50 psf"]] },
    { title: "SMARTSHELF (FIXED, FULL DEPTH)", blurb: "Montel's patented SmartShelf is the most versatile storage shelving system available today...", img: "assets/pipe2.png", tds: "#",
      specs: [["Width","24, 30, 36, 1M, 42, 48, 54\""],["Depth","12, 13, 15, 16, 18, 20, 24, 30, 36\""],["Height","30\" to 120\""],["Frame Load Capacity","Up to 2,500 lbs per frame"],["Shelf Load Capacity","Up to 500 lbs per shelf"]] },
    { title: "4D Wide Span", blurb: "Montel‚Äôs 4D Wide Span semi-industrial racking offers the ultimate solution...", img: "assets/pipe3.png", tds: "#",
      specs: [["Load per Bay","Up to 5,000 lbs per bay (2 268 kg)"],["Load per Level","3\" Beam: 1,000 lbs per pair (454 kg)"],["Span","4\" Beam: 1,500 lbs per pair (680 kg)"],["Height","4' to 8' (1.2 m to 2.4 m)"],["Depth","Up to 20' (6.1 m)"]] },
    { title: "SmartSpace", blurb: "Montel‚Äôs SmartSpace storage system offers a cost-effective and versatile solution...", img: "assets/pipe4.png", tds: "#",
      specs: [["Section Load Capacity","2,000 lbs per section (907 kg)"],["Section Length","24\" to 48\" (0.61 m ‚Äì 1.2 m)"],["Section Depth","Panels: 12\" to 48\"; Columns: 18\" to 48\""],["Carriage Load Capacity","16,000 lbs per carriage (7 270 kg)"],["Carriage Length","Max 24' (7.3 m)"]] },
    { title: "SmartGlide", blurb: "Montel‚Äôs SmartGlide push & glide modular lateral storage system is a compact, high-density movable shelving system...", img: "assets/pipe5.png", tds: "#", specs: [] },
    { title: "GREENRAK", blurb: "Montel‚Äôs GREENRAK¬Æ 2.0 mobile system has been developed specifically for growing applications...", img: "assets/greenrak.png", tds: "#",
      specTable: { headers:["Specification","Section","Mobile"], rows:[["Load","Max 2,400 lbs/section","Max 18,000 lbs/mobile"],["Depth","‚Äî","36\", 42\", 48\""],["Length","4‚Äô, 8‚Äô","Max 50‚Äô"]] } },
    { title: "Mobilex", blurb: "Montel's Mobilex mechanical-assist mobile storage systems provide your organization with the flexibility...", img: "assets/pipe7.png", tds: "#",
      specs: [["Load Capacity","1,000 lbs per linear foot (1 488 kg/m)"],["Depth","3' to 45' (0.91 m ‚Äì 13.7 m)"],["Length","15\" to 48\" (0.4 m ‚Äì 2.4 m)"]] },
    { title: "SAFERAK 32P & 60P", blurb: "Unlock the full potential of your storage with Montel‚Äôs cutting-edge powered mobile racking system...", img: "assets/pipe8.png", tds: "#",
      specTable: { headers:["Specification","SAFERAK 32P","SAFERAK 60P"], rows:[
        ["Load per Double-Bay","32,000 lbs (14 500 kg)","60,000 lbs (27 200 kg)"],
        ["Load per Carriage","256,000 lbs (116 000 kg)","480,000 lbs (217 600 kg)"],
        ["Bay Depth","Up to 8' (2.4 m)","Up to 8' (2.4 m)"],
        ["Bay Width","Up to 12' (3.6 m)","Up to 12' (3.6 m)"],
        ["Carriage Length","Up to 100‚Äô (30 m)","Up to 120‚Äô (36 m)"],
        ["Industrial Safeties","YES","YES"],
        ["PLC","YES","YES"],
        ["Touchscreen UI","YES","YES"],
        ["Signal Strobe and Buzzers","YES","YES"],
        ["VPN eWon Connectivity","YES","YES"],
        ["Rear Controls","Optional","Optional"],
        ["In-Aisle E-Stops","Optional","Optional"],
        ["Illuminated E-Stops","Optional","Optional"]
      ] } }
  ];

  // Preload system images (optional)
  const _imgCache = new Map();
  function preloadImage(url){
    if(!url || url==="#" || _imgCache.has(url)) return;
    const link = document.createElement('link');
    try{ link.rel='preload'; link.as='image'; link.href=url; document.head.appendChild(link); }catch(_){}
    const im = new Image(); im.decoding='async'; im.loading='eager';
    im.onload = ()=>_imgCache.set(url, im);
    im.onerror= ()=>_imgCache.set(url, null);
    im.src = url;
  }
  function preloadSystemImages(){ try{ SYSTEMS.forEach(s=>preloadImage(s.img)); }catch(_){} }

  /* ===== Fixed-step update + interpolation ===== */
  const FIXED_HZ = isMobile ? 120 : 240;
  const FIXED_DT = 1 / FIXED_HZ;
  const MAX_FRAME_DT = 0.1;
  let accumulator = 0;
  let lastTs = performance.now();

  function beforeStepCopyPrev(){
    bird.prevY = bird.y;
    for (const o of obstacles) o.prevX = o.x;
  }
  function loop(ts){
    let frameDt = (ts - lastTs) / 1000;
    if (frameDt > MAX_FRAME_DT) frameDt = MAX_FRAME_DT;
    if (frameDt < 0) frameDt = 0;
    lastTs = ts;

    accumulator += frameDt;

    while (accumulator >= FIXED_DT) {
      beforeStepCopyPrev();
      if(started && !over){
        physicsStep(FIXED_DT);
      }
      accumulator -= FIXED_DT;
    }

    const alpha = accumulator / FIXED_DT;

    ctx.clearRect(0,0,WORLD_W,WORLD_H);
    drawBackground();
    drawVPipes(alpha);
    drawHBar(alpha);
    bird.draw(alpha);

    ctx.fillStyle='rgba(255,255,255,.85)';
    ctx.font='700 16px Montserrat,system-ui';
    ctx.fillText('v'+VERSION, 14, WORLD_H-14);

    requestAnimationFrame(loop);
  }

  /* ===== Flow ===== */
  function startGame(){
    started=true; over=false; restartLocked=false; spawnTimer=0;
    spawnedHorizontalTest = false;
    lastScore = score; lastEl.textContent = lastScore;
    score = 0; scoreEl.textContent = "0";
    obstacles.length = 0; bird.reset();
    startCard.classList.add('hidden');
    gameOverCard.classList.add('hidden');
  }
  function endGame(hitStyleIdx=null){
    if(over) return;
    over=true;
    playHit();
    finalScoreP.textContent = `Score: ${score} ‚Ä¢ Best: ${best}`;

    const box   = document.getElementById('sysInfoBox');
    const imgEl = document.getElementById('sysImg');
    const tEl   = document.getElementById('sysTitle');
    const bEl   = document.getElementById('sysBlurb');
    const specsBox = document.getElementById('sysSpecsBox');
    const sEl   = document.getElementById('sysSpecs');
    const lEl   = document.getElementById('sysLinks');

    box.style.display = 'none'; imgEl.style.display='none'; // keep it simple here

    gameOverCard.classList.remove('hidden');
    gameOverCard.scrollTop = 0;
    requestAnimationFrame(()=>{ gameOverCard.scrollTop = 0; });
    setTimeout(()=>{ gameOverCard.scrollTop = 0; }, 50);

    updateFsBtn();
    restartLocked = true; setTimeout(()=>{ restartLocked=false; }, 1000);
  }
  function forceToStartScreen(){
    started=false; over=false; restartLocked=false;
    ctx.clearRect(0,0,WORLD_W,WORLD_H);
    drawBackground();
    bird.reset(); bird.draw(0);
    startCard.classList.remove('hidden');
    startCard.scrollTop = 0;
    requestAnimationFrame(()=>{ startCard.scrollTop = 0; });
    setTimeout(()=>{ startCard.scrollTop = 0; }, 50);
    gameOverCard.classList.add('hidden');
    updateFsBtn();
  }

  /* ===== INPUT ===== */
  let lastTap=0;
  startCard.addEventListener('click', handleTap, {passive:false});
  startCard.addEventListener('touchstart', (e)=>{ handleTap(e); }, {passive:false});
  async function handleTap(e){
    if(e){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){ } }
    try { await initAudioOnce(); try { await audioCtx.resume(); } catch(_){} setMuted(muted); } catch(_){}
    const now = performance.now(); if (now - lastTap < 140) return; lastTap = now;
    if(!started){ startGame(); bird.flap(); return; }
    if(!over){ bird.flap(); return; }
    if(!restartLocked) startGame();
  }
  function docTapGate(e){
    if (!started && !startCard.classList.contains('hidden')) { handleTap(e); return; }
    if (!gameOverCard.classList.contains('hidden')) {
      if (e.target.closest('#gameOverCard')) return;
      if (e.target.closest('#muteBtn, #fsBtn')) return;
      handleTap(e); return;
    }
    if (!e.target.closest('#muteBtn, #fsBtn')) handleTap(e);
  }
  document.addEventListener('pointerdown', docTapGate, {passive:false, capture:true});
  document.addEventListener('touchstart', docTapGate, {passive:false, capture:true});
  document.addEventListener('click', docTapGate, {passive:false, capture:true});

  /* ===== Boot (gated) ===== */
  const BG_URL   = "assets/bg.png";
  const BIRD_URL = "assets/bird.png";
  let bgImg = null, birdImg = null;

  (async function gatedBoot(){
    const loadingEl = document.getElementById('loadingOverlay');

    const [bg, bird] = await Promise.all([
      loadImageWithTimeout(BG_URL),
      loadImageWithTimeout(BIRD_URL)
    ]);

    bgImg   = bg   || buildFallbackBG();
    birdImg = bird || buildFallbackBird();

    forceToStartScreen();
    checkOrientation();
    lastTs = performance.now();
    requestAnimationFrame(loop);

    setTimeout(()=>{ if (loadingEl) loadingEl.style.display = 'none'; }, 30);

    // Preload pipe images
    const promises = [];
    for (const s of PIPE_STYLES_CFG){
      promises.push(loadImageWithTimeout(s.bottom.url));
      promises.push(loadImageWithTimeout(s.top.url));
    }
    const results = await Promise.allSettled(promises);
    const bottoms=[], tops=[];
    for(let i=0;i<PIPE_STYLES_CFG.length;i++){
      bottoms[i] = results[i*2]?.value || null;
      tops[i]    = results[i*2+1]?.value || null;
    }
    Raw.bottoms = bottoms; Raw.tops = tops;
    rebuildStyles();
  })();

})(); // end IIFE
</script>

</body>
</html>
